<!--
|     Copyright (C) 2010-2015 Marvell International Ltd.
|     Copyright (C) 2002-2010 Kinoma, Inc.
|
|     Licensed under the Apache License, Version 2.0 (the "License");
|     you may not use this file except in compliance with the License.
|     You may obtain a copy of the License at
|
|      http://www.apache.org/licenses/LICENSE-2.0
|
|     Unless required by applicable law or agreed to in writing, software
|     distributed under the License is distributed on an "AS IS" BASIS,
|     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
|     See the License for the specific language governing permissions and
|     limitations under the License.
-->
<module xmlns="http://www.kinoma.com/kpr/1">
    
    <require id="DebugHandlerMessageBehavior" path="DebugHandlerMessageBehavior"/>
    <require id="AuthenticatedDebugHandlerMessageBehavior" path="AuthenticatedDebugHandlerMessageBehavior"/>
    <require id="ApplicationManager" path="ApplicationManager"/>
    <require id="Logger" path="Logger"/>
    <require id="Preferences" path="Preferences"/>
    <require id="TransitionHelper" path="TransitionHelper"/>
    
    <function id="getBehavior">
        <![CDATA[
            return shell.behavior;
        ]]>
    </function>
    
    <variable id="START_MESSAGE" value="'%com.kinoma.debug=start'"/>
    <variable id="STOP_MESSAGE" value="'%com.kinoma.debug=stop'"/>
    
    <script>
        <![CDATA[
            // define constant values that we don't want exported by the module
            var CREDENTIALS = "credentials";
            var DEFAULT_PASSWORD = "kinoma";
            var UPLOAD_PATH = getEnvironmentVariable( "uploadPath" );
        ]]>
    </script>

    <class id="DebugBehavior" like="Behavior">
        <field id="preferences"/>
        <field id="applicationManager"/>
        <field id="menuBar"/>
        <field id="selectedApplication"/>
        <field id="applicationContainer"/>
        <field id="background"/>
        <field id="applicationBackground"/>
        <field id="profiling"/>
        <field id="profilingDirectory"/>
        <field id="systemModulePath"/>
        <field id="breakpoints"/>
        <field id="shareConfig"/>
    
        <method id="initialize">
            <![CDATA[
                // save system module path
                this.systemModulePath = getEnvironmentVariable( "modulePath" );

                // create the preferences object
                this.preferences = Preferences.newInstance( this.getPreferencesPath() );

                // allow the debug behavior to initialize defaults from preferences
                this.initializePrefernces();

                // finish initializing the behavior
                this.applicationManager = ApplicationManager.newInstance( this.getApplicationSearchPaths(), this.getUploadPath( true ) );
                this.menuBar = this.createMenuBar();
                this.background = this.createBackground();
                
                // create the background container
                if( this.background != null )
                    shell.add( this.background );

                shell.windowTitle = this.getWindowTitle();
                shell.menus = this.menuBar != null ? this.menuBar.menus : null;
            ]]>
        </method>
        
        <method id="isDebuggingAllowed">
            <![CDATA[
                return this.getPreferences().getPreference( "allowDebugging", "on" ) == "on";
            ]]>
        </method>
        
        <method id="onLaunch" params="shell">
            <![CDATA[
            ]]>
        </method>

        <method id="getPreferences">
            <![CDATA[
                return this.preferences;
            ]]>
        </method>
    
        <method id="initializePrefernces"/>
        <method id="exit"/>
    
        <method id="getSystemModulePath">
            <![CDATA[
                return this.systemModulePath;
            ]]>
        </method>

        <method id="createBackground">
            <![CDATA[
                return new Container( {left: 0, right: 0, top: 0, bottom: 0}, new Skin( this.getBackgroundColor() ) );
            ]]>
        </method>

        <method id="getBackgroundColor">
            <![CDATA[
                return "black";
            ]]>
        </method>
        
        <method id="createMenuBar">
            <![CDATA[
                return null;
            ]]>
        </method>
        
        <method id="setCredentials" params="credentials">
            <![CDATA[
                this.getPreferences().setPreference( CREDENTIALS, credentials );
                this.getPreferences().write();
            ]]>
        </method>
        
        <method id="getDefaultCredentials">
            <![CDATA[
                return {username: "kinoma", password: DEFAULT_PASSWORD, required: true};
            ]]>
        </method>
        
        <method id="getCredentials">
            <![CDATA[
                return this.getPreferences().getPreference( CREDENTIALS, this.getDefaultCredentials() );
            ]]>
        </method>

        <method id="getWindowTitle">
            <![CDATA[
                return "";
            ]]>
        </method>

        <method id="getInfo" params="temporary">
            <![CDATA[
                var info = new Object();
                var uploadPath = this.getUploadPath( temporary == false ? false : true );

                info.root = uploadPath.substring( "file://".length );
                info.hwpdir = this.getHardwarePinsModulePath();             
                                
                return info;
            ]]>
        </method>
        
        <method id="getDescription">
            <![CDATA[
                var description = new Object();
                
                description.version = getEnvironmentVariable( "CORE_VERSION" );
                description.uuid = shell.uuid;
                description.name = this.getDeviceName();
                description.id = this.getDeviceId();
                
                // add studio info
                description.studio = new Object();
                description.studio.version = this.getStudioVersion();
                description.studio.locked = this.getStudioIsLocked();
                description.studio.compile = this.getStudioCompileOption();
                description.studio.install = this.getStudioInstallOption();
                description.studio.profile = this.getStudioIsProfilerSupported();
                
                // add the studio services
                description.studio.services = this.getStudioServices();
                
                // TODO: remove the following lines!!! left in place for backwards compatibility
                // until next stable studio release is available.
                description.debugShell = true;
                description.locked = description.studio.locked;
                
                return description;
            ]]>
        </method>
        
        <method id="getDeviceName">
            <![CDATA[
               var deviceInfo = getPreferences().getPreference( "deviceInfo", null );
                           
               if( deviceInfo != null && "name" in deviceInfo && deviceInfo.name != null && deviceInfo.name.length > 0 )
                   return deviceInfo.name;
               else
                   return getEnvironmentVariable( "defaultDeviceName" ) || this.getDefaultDeviceName();
            ]]>
        </method>
        
        <method id="getDefaultDeviceName">
            <![CDATA[
                return "Kinoma Device";
            ]]>
        </method>
        
        <method id="getDeviceId">
            <![CDATA[
                return "com.marvell.kinoma.unknown";
            ]]>
        </method>
        
        <method id="getStudioVersion">
            <![CDATA[
                return "1.3.49";
            ]]>
        </method>
        
        <method id="getStudioIsLocked">
            <![CDATA[
                var credentials = this.getCredentials();

                return credentials != null && credentials.required == true && credentials.password != DEFAULT_PASSWORD;
            ]]>
        </method>
        
        <method id="getStudioCompileOption">
            <![CDATA[
                return "optional";
            ]]>
        </method>
        
        <method id="getStudioInstallOption">
            <![CDATA[
                return "optional";
            ]]>
        </method>
        
        <method id="getStudioIsProfilerSupported">
            <![CDATA[
                return true;
            ]]>
        </method>
        
        <method id="getStudioServices">
            <![CDATA[
                var services = new Object();
                
                services.diagnostics = { path: "/diagnostics" };
                
                if( this.getLogFilePath() != null )
                    services.logs = { path: "/logs" };
                
                return services;
            ]]>
        </method>
        
        <method id="getDiagnostics">
            <![CDATA[
                var diagnostics = new Object();
                
                diagnostics.systemModulePath = this.getSystemModulePath().split( ";" );
                diagnostics.modulePath = getEnvironmentVariable( "modulePath" ).split( ";" );
                diagnostics.preferencesPath = this.getPreferencesPath();
                diagnostics.preferences = this.getPreferences().preferences;
                diagnostics.applicationSearchPaths = this.getApplicationSearchPaths();
                diagnostics.uploadPath = this.getUploadPath();
                diagnostics.tempUploadPath = this.getUploadPath( true );
                diagnostics.logFilePath = this.getLogFilePath();
                diagnostics.hwpModulePath = this.getHardwarePinsModulePath();
                diagnostics.profilingDirectory = this.profilingDirectory;
                diagnostics.applications = [];
                
                for( var j = 0; j < this.getApplicationManager().getExtensionCount(); j++ )
                {
                    var info = this.getApplicationManager().getExtensionByIndex( j );
                    var app = new Object();
                    
                    app.title = info.title;
                    app.id = info.id;
                    app.url = info.url;                    
                    
                    diagnostics.applications.push( app );
                }
                
                return diagnostics;
            ]]>
        </method>
        
        <method id="getApplicationSearchPaths">
            <![CDATA[
                return null;
            ]]>
        </method>
        
        <method id="getPreferencesPath">
            <![CDATA[
                return Files.preferencesDirectory + "kdt/preferences.json";
            ]]>
        </method>

        <method id="getUploadPath" params="temporary">
            <![CDATA[
            	if (temporary)
                   return mergeURI( UPLOAD_PATH != null ? UPLOAD_PATH : Files.preferencesDirectory, "kdt/cache" );
                return mergeURI( Files.preferencesDirectory, "kdt/samples" );
            ]]>
        </method>
        
        <method id="getManifestPath" params="path, temporary">
            <![CDATA[
                return this.getUploadPath( temporary ) + "/" + path + "/.manifest";
            ]]>
        </method>
        
        <method id="getLogFilePath">
            <![CDATA[
                return null;
            ]]>
        </method>
        
        <method id="getApplicationManager">
            <![CDATA[
                return this.applicationManager;
            ]]>
        </method>
        
        <method id="getShareConfig">
            <![CDATA[
                if( this.shareConfig == null )
                {
                    var ssdpconf = getEnvironmentVariable( "ssdpconf" );                    
                    var allowdesc = getEnvironmentVariable( "allowdesc" );
                    
                    this.shareConfig = new Object();
                    this.shareConfig.ssdp = ssdpconf == null || ssdpconf == "true";
                    this.shareConfig.allowdesc = allowdesc == null || allowdesc == "true";
                }
            
                return this.shareConfig;
            ]]>
        </method>

        <method id="getSelectedApplication">
            <![CDATA[
                return this.selectedApplication;
            ]]>
        </method>
        
        <method id="getApplicationContainer">
            <![CDATA[
                return this.applicationContainer;
            ]]>
        </method>
        
        <method id="setSelectedApplication" params="applicationInfo, debug, breakOnExceptions">
            <![CDATA[
                if( applicationInfo != this.selectedApplication )
                {
                    var oldApplicationContainer = this.applicationContainer;
                    var boe = breakOnExceptions != null ? breakOnExceptions : true;

                    this.setApplicationEnvironment( applicationInfo );
                    
                    // send pins vm initialization options to pins vm
                    shell.invoke( new Message( "pins:breakOnException?break=" + boe ) );
                    shell.invoke( new Message( "pins:breakOnLaunch?break=" + (debug ? "true" : "false") ) );
                    
                    this.applicationContainer = this.getApplicationManager().createApplicationContainer( applicationInfo, debug, boe );
                    
                    if( oldApplicationContainer != null )
                        this.getScreen().run( new TransitionHelper.PushTransition( 350, oldApplicationContainer, this.applicationContainer, TransitionHelper.LEFT, 0 ) );
                    
                    else
                    {
                        this.getScreen().add( this.applicationContainer );
                        
                        this.applicationContainer.launch();
                        this.applicationContainer.adapt();
                        
                        this.applicationStarted();
                    }
                    
                    if( this.profiling )
                    {
                       if( this.profilingDirectory != null )
                           this.applicationContainer.profilingDirectory = this.profilingDirectory;
                       
                       this.applicationContainer.profiling = true;
                    }
                    
                    this.selectedApplication = applicationInfo;
                }
            ]]>
        </method>
        
        <method id="setInputEvents" params="events"/>
        
        <method id="setApplicationEnvironment" params="applicationInfo">
            <![CDATA[
                if( applicationInfo.environment != null ) 
                    this.setEnvironment( applicationInfo.environment, applicationInfo.temporary );
                
                // get the current module path
                var modulePath = getEnvironmentVariable( "modulePath" );

                //
                // ensure that the application program's parent path is in
                // the specified modulePath list...
                //
                var program = applicationInfo.program;
                var url = program.slice( 0, program.lastIndexOf( "/" ) + 1 );
                var path = url.slice( 7 );

                if( modulePath != null )
                {
                    var modulePathList = modulePath.split( ";" );
                    var required = true;
                    
                    for( var j = 0; j < modulePathList.length; j++ )
                    {
                        if( modulePathList[j] == path || modulePathList[j] == url ) {
                            required = false;
                            break;
                        }
                    }
                    
                    if( required )
                        modulePath = modulePath + ";" + path;
                }
                else
                    modulePath = path;

                //    
                // add default module path for application hardwarepins blls
                //
                var hwpModulePath = this.getHardwarePinsModulePath();
                
                if( hwpModulePath != null )
                {
                    url = mergeURI( applicationInfo.url, "./" + hwpModulePath + "/" );

                    if( Files.exists( url ) == Files.directoryType )
                    {
                        
                        if( modulePath == null )
                            modulePath = url;
                        else
                            modulePath = modulePath + ";" + url.slice( 7 );
                    }    
                }
                
                setEnvironmentVariable( "modulePath", modulePath );
            ]]>
        </method>
        
        <method id="getHardwarePinsModulePath">
            <![CDATA[
                return getEnvironmentVariable( "hwpModulePath" );
            ]]>
        </method>
        
        <method id="applicationStarted"/>
        <method id="applicationStopped"/>
        
        <method id="getScreen">
            <![CDATA[
                return null;
            ]]>
        </method>

        <method id="setProfiling" params="profiling, directory">
            <![CDATA[
                if( this.profiling != profiling )
                {
                    this.profiling = profiling;
                    
                    if( directory != null )
                        this.profilingDirectory = directory.indexOf( "file://" ) == 0 ? directory : "file://" + directory + "/";
                    
                    if( this.applicationContainer != null )
                    {
                        if( profiling )
                        {
	                        if( this.profilingDirectory != null )
	                            this.applicationContainer.profilingDirectory =  this.profilingDirectory;
	                    }
                    
                        this.applicationContainer.profiling = profiling;
                    }
                }
            ]]>
        </method>

        <method id="connect" params="host, port">
            <![CDATA[
                setEnvironmentVariable( "debugger", port != null ? host + ":" + port : host );
                shell.debugging = true;
            
                Logger.log( START_MESSAGE );
            ]]>
        </method>

        <method id="disconnect" params="terminate">
            <![CDATA[
                //trace( "### disconnect: " + terminate + "\n" );
            
                if( this.applicationContainer != null )
                {
                    if( this.applicationContainer.debugging )
                    {
                        Logger.log( STOP_MESSAGE, false, this.applicationContainer );
                
                        this.applicationContainer.debugging = false;
                    }
                    
                    if( terminate )
                    {
                        this.applicationContainer.quit();
                        
                        this.getScreen().remove( this.applicationContainer );
                        
                        this.applicationContainer = null;
                        
                        this.applicationStopped();
                    }
                    
                    this.selectedApplication = null;
                    
                    //shell.debugging = false;
                    
                    // reset the modulePath environment variable
                    setEnvironmentVariable( "modulePath", this.getSystemModulePath() );
                }
            ]]>
        </method>
        
        <method id="getApplicationContainerFromParams" params="params">
            <![CDATA[
                var applicationInfo = null;
                var applicationContainer = null;

                if( params.contains( "id" ) )
                    applicationInfo = this.getApplicationManager().getExtensionById( params.getValue( "id" ) );
                    
                else if( params.contains( "url" ) )
                    applicationInfo = this.getApplicationManager().getExtensionByUrl( params.getValue( "url" ) );
                
                if( applicationInfo == this.selectedApplication )
                    applicationContainer = this.applicationContainer;
                
                return applicationContainer;
            ]]>
        </method>

        <method id="installApplication" params="url, temporary">
            <![CDATA[            
                var applicationInfo = this.getApplicationManager().registerExtension( url, temporary );
                    
                return applicationInfo;
            ]]>
        </method>

        <method id="uninstallApplication" params="url">
            <![CDATA[            
				var applicationManager = this.getApplicationManager();
				var applicationInfo = applicationManager.getExtensionByUrl( url );
				if( applicationInfo )
				{
					applicationManager.unregisterExtension( applicationInfo );
					var persistentPath = this.getUploadPath( false );
					var temporaryPath = this.getUploadPath( true );
					if( (url.indexOf( persistentPath ) == 0) || (url.indexOf( temporaryPath ) == 0) )
					{
						var path = applicationInfo.url.slice( 0, url.lastIndexOf( "/" ) ) + "/";
						Files.deleteDirectory( path, true );
					}
                }
                return applicationInfo;
            ]]>
        </method>

        <method id="setEnvironment" params="variables, temporary">
            <![CDATA[
                for( var next in variables )
                {
                    //trace( "#### SETTING ENVIRONMENT VARIABLES:\n" );
                    //trace( "####     " + next + "=" + variables[next] + "\n" );
                    if( next == "modulePath" )
                    {
                        var modifiedModulePath = variables[next].replace( "@", getBehavior().getUploadPath( temporary ) );
                        var modulePath = getBehavior().getSystemModulePath() != null ? getBehavior().getSystemModulePath() + ";" + modifiedModulePath : modifiedModulePath;
                        
                        setEnvironmentVariable( next, modulePath );
                    }
                    else
                        setEnvironmentVariable( next, variables[next] );
                }
            ]]>
        </method>

        <method id="processManifest" params="path">
            <![CDATA[
                var manifest = Files.readJSON( path );
                var root = mergeURI( path, "./" );
            
                this.pruneManifestDirectory( root, root, manifest );
            ]]>
        </method>
        
        <method id="pruneManifestDirectory" params="path, root, manifest">
            <![CDATA[
                var it = new Files.Iterator( path );
                var next = it.getNext();
                var pendingDeleteFileList = [];
                
                while( next != null )
                {
                    if( next.type == Files.directoryType )
                        this.pruneManifestDirectory( mergeURI( path, next.path + "/" ), root, manifest );
                        
                    else
                    {
                        var file = mergeURI( path, next.path );
                        var entry = file.substring( root.length );
                        var version = "version" in manifest ? manifest.version : 1;

                        if( version == 2 )
                        {
                           var remove = true;
                        
                           // check to see if the file is in the manifest, and if it is
                           // not then add it to the pending delete list...
                           for( var j = 0; j < manifest.files.length; j++ )
                           {
                              if( manifest.files[j].path == entry ) {
                                 remove = false;
                                 break;
                              }
                           }
                           
                           if( remove )
                              pendingDeleteFileList.push( file );
                        }
                        else if( version == 1 )
                        {
                           // if the compile option is set in the manifest
                           // then js and xml programs and modules are saved
                           // as jsb files in the application cache
                           if( "compile" in manifest && manifest.compile == true )
                           {
                               var extensionIndex = entry.lastIndexOf( "." );
                               var extension = entry.substring( extensionIndex + 1 ).toLowerCase();
                               
                               // if the file extensions is jsb then check to see if there is a 
                               // corresponding jsb, js, or xml file in the manifest... otherwise 
                               // delete the jsb file...
                               if( extension == "jsb" )
                               {
                                   var entry = entry.substring( 0, extensionIndex + 1 );
   
                                   if( ((entry + "jsb") in manifest.checksums || (entry + "js") in manifest.checksums || (entry + "xml") in manifest.checksums) == false )
                                       pendingDeleteFileList.push( file );
                               }
                               
                               // if the file extension is js or xml and we are compiling, then
                               // check if there is a corresponding jsb file... if there is a
                               // jsb then assume that the js/xml file is obsolete...
                               else if( extension == "js" || extension == "xml" )
                               {
                                   var entry = mergeURI( root, entry.substring( 0, extensionIndex + 1 ) + "jsb" );
                                   
                                   if( Files.exists( entry ) == Files.fileType )
                                       pendingDeleteFileList.push( file );
                               }                 
                           }
                           
                           // check to see if the file has an entry in the
                           // manifest checksum map... if it doesn't then
                           // we should remove it from the cache           
                           else if( (entry in manifest.checksums) == false )
                               pendingDeleteFileList.push( file );
                        }
                    }
                        
                    next = it.getNext();
                }
                
                for( var j = 0; j < pendingDeleteFileList.length; j++ )
                    Files.deleteFile( pendingDeleteFileList[j] );
            ]]>
        </method>

        <method id="handleUploadBegan" params="path, size"/>        
        <method id="handleUploadEnded"/>
        <method id="handleMessageBegin" params="message"/>
        <method id="handleMessageEnd" params="message"/>
        <method id="handleShellQuit" params="message"/>

        <method id="handleLaunch" params="launch">
            <![CDATA[
                var temporary = "temporary" in launch ? launch.temporary : true;
                var application = "application" in launch ? launch.application : null;
                var profiler = "profiler" in launch ? launch.profiler : null;

	            var applicationInfo = null;
	            
	            if( application != null )
	            {
	               if( "id" in application )
	                   applicationInfo = this.getApplicationManager().getExtensionById( application.id );

                   if( applicationInfo != null )
                   {
                       if( temporary != applicationInfo.temporary )
                       {
                          this.uninstallApplication( applicationInfo.url );
                          applicationInfo = null;
                       }
                   }

	               if( applicationInfo == null )
	               {
	                   if( "path" in application )
	                       applicationInfo = this.installApplication( "file://" + application.path, temporary );
	                   
	                   else if( "app" in application )
	                       applicationInfo = this.installApplication( this.getUploadPath( temporary ) + "/" + application.app, temporary );
	               }
	            }
	            
	            if( profiler != null )
				{
				    var enabled = "enabled" in profiler && profiler.enabled == true;
				    var path = "path" in profiler ? profiler.path : mergeURI( shell.url, "../" );
				    
				    this.setProfiling( enabled, path );
				}
	            
	            if( applicationInfo != null )
	            {
	                // set the application info enviroment variables
	                if( "environment" in launch )
                        applicationInfo.environment = launch.environment;           
	            
	                // set the initial breakpoins
	                if( "breakpoints" in launch )
	                   this.setBreakpoints( launch.breakpoints );
	                
	                // send a message to the shell to start the application, because if
	                // we call setSelectedApplication() directly the interface may not
	                // be fully ready after installing the application... this is the case
	                // with the tiles in the create shell.
	                var debug = ("debug" in launch && launch.debug == true) ? "true" : "false";
	                var breakOnExceptions = ("breakOnExceptions" in launch && launch.breakOnExceptions == true) ? "true" : "false";
	                
	                shell.invoke( new Message( "xkpr://shell/start?id=" + applicationInfo.id + "&debug=" + debug + "&breakOnExceptions=" + breakOnExceptions ) );
                }
            ]]>
        </method>

        <method id="setBreakpoints" params="breakpoints">
            <![CDATA[
                this.breakpoints = breakpoints;    
                this.handleSetBreakpoints( breakpoints );
            ]]>
        </method>
        
        <method id="handleSetBreakpoints" params="breakpoints">
            <![CDATA[
                if( breakpoints != null )
                {
	                var host = this.getApplicationContainer();
	
	                if( host != null )
	                {
	                    // 
	                    // first clear all of the breakpoints in the
	                    // host and in the pins VM
	                    // 
	                    host.clearAllBreakpoints();
	                    
	                    var message = new Message("pins:clearAllBreakpoints");
	                    
	                    message.setRequestHeader("referrer", "xkpr://" + host.id);
	                    
	                    shell.invoke(message);
	                    
	                    //
	                    // iteratre through all of the breakpoints and enable
	                    // them in the host and pins VM
	                    //
		                for( var j = 0; j < breakpoints.length; j++ )
		                {
		                    host.setBreakpoint( breakpoints[j].file, breakpoints[j].line );
		                
		                    var message = new Message( "pins:setBreakpoint?" + serializeQuery( breakpoints[j] ) );
		                    
		                    message.setRequestHeader( "referrer", "xkpr://" + host.id );
		                    
		                    shell.invoke( message );
		                }
		            }  
		        }  
            ]]>
        </method>

        <method id="onQuit">
            <![CDATA[
                this.exit();
            ]]>
        </method>
    </class>

    <!-- export the main prototype -->
    <variable id="prototype" value="DebugBehavior.prototype"/>

    <!-- debug handlers -->
    <handler path="/ping">
        <behavior like="DebugHandlerMessageBehavior"/>
    </handler>

    <handler path="/description">
        <behavior like="DebugHandlerMessageBehavior">
            <method id="onAccept" params="handler, message">
                <![CDATA[
                    return getBehavior().getShareConfig().allowdesc;
                ]]>
            </method>            
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    message.responseText = JSON.stringify( getBehavior().getDescription() );
                ]]>
            </method>
        </behavior>
    </handler>

    <handler path="/description/icon">
        <behavior like="DebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                    var url = getBehavior().getIcon();
					
                    if( Files.exists( url ) )
                       message.responseBuffer = Files.readBuffer( url );
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/">  <!-- this should change to a path like dd.xml, but doing so requires simultaneously updating the SSDP announcement -->
        <behavior like="DebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                    var url = mergeURI(shell.url, "upnp/dd.xml");

                    if( Files.exists( url ) )
                    {
                        var text = Files.readText( url );

                        var name = getBehavior().getDescription().name;
                        text = text.replace("[friendlyName]", name ? name : "Kinoma Create");
                        text = text.replace("[udn]", shell.uuid);
                        
                        //@@ version

                        message.setResponseHeader("Content-Type", "text/xml; charset=\"utf-8\"");
                        message.responseText = text;
                    }
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/info">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    var temporary = params.getBool( "temporary", true );         

                    message.responseText = JSON.stringify( getBehavior().getInfo( temporary ) );
                ]]>
            </method>
        </behavior>
    </handler>
    
    <handler path="/connect">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                    var host = params.getValue( "host", "localhost" );
                    var port = params.getValue( "port" );
                    var temporary = params.getBool( "temporary", true );         

                    getBehavior().connect( host, port );
                    
                    message.responseText = JSON.stringify( getBehavior().getInfo( temporary ) );
                }
            ]]>
        </behavior>
    </handler>
    
    <handler path="/disconnect">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) {
                    getBehavior().disconnect( params.getBool( "terminate", true ) );
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/break">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                /*
                    if( params.contains( "id" ) || params.contains( "url" ) )
                    {
                        var applicationContainer = getBehavior().getApplicationContainerFromParams( params );
                        
                        // call the debugger function in the target application container
                        if( applicationContainer != null && "debugger" in applicationContainer)
                          applicationContainer["debugger"]();
                    }
                    else if( getBehavior().applicationContainer != null && "debugger" in getBehavior().applicationContainer )
                       getBehavior().applicationContainer["debugger"]();
                    
                    else
                */
                    debugger;
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/trace">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                    var query = parseQuery( message.query );
                    var traceInApplication = "id" in query || "url" in query;
                    
                    if( params.contains( "id" ) || params.contains( "url" ) )
                    {
                        var applicationContainer = getBehavior().getApplicationContainerFromParams( params );
                        
                        // call the trace function in the target application container
                        if( applicationContainer != null )
                            Logger.log( params.getValue( "out", "" ), true, applicationContainer );
                    }
                    else
                        Logger.log( params.getValue( "out", "" ), true );
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/install">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {    
                	var temporary = params.getBool( "temporary", true );         
                    var url = null;
                
                    if( params.contains( "path" ) )
                       url = "file://" + params.getValue( "path" );
                    
                    else if( params.contains( "url" ) )
                       url = params.getValue( "url" );
                       
                    else if( params.contains( "app" ) )
                       url = getBehavior().getUploadPath( temporary ) + "/" + params.getValue( "app" );
                       
                    getBehavior().installApplication( url, temporary );
                }
            ]]>
        </behavior>
    </handler>

	<handler path="/uninstall">
		<behavior like="AuthenticatedDebugHandlerMessageBehavior">
			<method id="processMessage" params="handler, message, params"><![CDATA[
				var model = getBehavior();
				var url = null;
				
				if (params.contains( "id" ))
				{
					var applicationInfo = model.getApplicationManager().getExtensionById( params.getValue( "id" ) );
					if( applicationInfo )
						url = applicationInfo.url;
				}
				
				else if (params.contains( "path" ))
					url = "file://" + params.getValue( "path" );
					
				else if (params.contains( "url" ))
					url = params.getValue( "url" );
					
				else if (params.contains( "app" ))
					url = model.getUploadPath(params.getBool( "temporary", true )) + "/" + params.getValue( "app" );

				if( url )
					model.uninstallApplication( url );
			]]></method>
        </behavior>
    </handler>
    
    <handler path="/launch">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function processMessage( handler, message, params ) 
                {
                    if( message.method == "POST" )
                        getBehavior().handleLaunch( JSON.parse( message.requestText ) );

                    else if( message.method == "GET" )
                    {
                        var applicationId = params.getValue( "id" );
                        var launch = {};
	                    
                        launch.application = { id:applicationId };
                       
                        getBehavior().handleLaunch( launch );
	                 }
                }
            ]]>
        </behavior>
    </handler>
    
    <handler path="/start">
        <behavior like="DebugHandlerMessageBehavior">
	        <method id="onAccept" params="handler, message">
	            <![CDATA[
	                return false;
	            ]]>
	        </method>
	        <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    var applicationInfo = getBehavior().getApplicationManager().getExtensionById( params.getValue( "id" ) );
                    
                    if( applicationInfo != null )
                        getBehavior().setSelectedApplication( applicationInfo, params.getBool( "debug", false ), params.getBool( "breakOnExceptions", true ) );
                ]]>
            </method>
        </behavior>
    </handler>

	<handler path="/upload">
		<behavior like="AuthenticatedDebugHandlerMessageBehavior">
			<method id="onAccept" params="handler, message">
            <![CDATA[
               if( message.method == "PUT" ) 
               {
                  var params = new DebugHandlerMessageBehavior.MessageParams( message );
                  
                  if( params.contains( "path" ) ) 
                  {
                     var path = getBehavior().getUploadPath(params.getBool("temporary", true)) + "/" + params.getValue( "path" );
                     
                     Files.ensureDirectory(path);
                     
                     message.requestPath = path;
                     
                     getBehavior().handleUploadBegan(path, message.getRequestHeader("Content-Length"));
                     
                     return true;
                  }
               }
               else if( message.method == "OPTIONS" )
                  return true;
			   ]]>
         </method>
			<method id="processMessage" params="handler, message, params">
            <![CDATA[
               if( message.method == "PUT" )
                  getBehavior().handleUploadEnded();
			   ]]>
         </method>
		</behavior>
	</handler>

	<handler path="/unload">
		<behavior like="AuthenticatedDebugHandlerMessageBehavior">
			<method id="processMessage" params="handler, message, params"><![CDATA[
				if( params.contains( "path" ) ) {
                    var url = getBehavior().getUploadPath(params.getBool( "temporary", true )) + "/" + params.getValue( "path" );
                    var info = Files.getInfo( url );
                    if( info )
                    {
						if (info.type == Files.directoryType)
							Files.deleteDirectory( url );
						else
							Files.deleteFile( url );
                    }
                }
			]]></method>
		</behavior>
	 </handler>
   
    <handler path="/manifest">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <![CDATA[
                function onAccept( handler, message )
                {
                    var accept = true;                 
                        
                    if( message.method == "PUT" ) 
                    {
                        var params = new DebugHandlerMessageBehavior.MessageParams( message );
                        
                        if( params.contains( "path" ) )
                        {
                            var manifestPath = getBehavior().getManifestPath( params.getValue( "path"  ),  params.getBool( "temporary", true ) );
                            
                            Files.ensureDirectory( manifestPath );
                        
                            message.requestPath = manifestPath;
                        }
                        else
                            accept = false;
                    }
                    
                    return accept;
                }

                function processMessage( handler, message, params ) 
                {
                    var manifestPath = getBehavior().getManifestPath( params.getValue( "path" ),  params.getBool( "temporary", true ) );

                    if( message.method == "PUT" ) 
                        getBehavior().processManifest( manifestPath );
                        
                    else if( message.method == "GET" )
                    {
                        if( Files.exists( manifestPath ) )
                            message.responsePath = manifestPath;
                        else
                            message.responseText = JSON.stringify( new Object() );
                    }
                }
            ]]>
        </behavior>
    </handler>

    <handler path="/environment">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    if( message.method == "POST" )
                        getBehavior().setEnvironment( JSON.parse( message.requestText ), true );
                    else
                        getBehavior().setEnvironment( params.params, true );
                ]]>
            </method>
        </behavior>
    </handler>

    <handler path="/setBreakpoints">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    if( message.method == "POST" )
                        getBehavior().setBreakpoints( JSON.parse( message.requestText ) )
                ]]>
            </method>
        </behavior>
     </handler>

    <handler path="/profile">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    var action = params.getValue( "action" );
                    var directory = params.getValue( "directory", mergeURI( shell.url, "../" ) );
                    var records = mergeURI( directory, "xsprofile.records.out" );
                    var symbols = mergeURI( directory, "xsprofile.symbols.out" );
                    
                    switch( action )
                    {
                        case "start":
                            // delete the profiler data if it exists before we start profiling
                            Files.deleteFile( records );
                            Files.deleteFile( symbols );
                        
                            // start profiling
                            getBehavior().setProfiling( true, directory );
                            break;
                            
                        case "stop":
                            getBehavior().setProfiling( false );
                            break;
                            
                        case "get":
                            var file = params.getValue( "file" );
                            var url = null;
                            
                            switch( file )
                            {
                                case "records":
                                   url = records;
                                   break;
                                   
                                case "symbols":
                                   url = symbols;
                                   break;
                            }
                            if( url != null && Files.exists( url ) != null )
                                message.responseChunk = Files.readChunk( url );
                            else
                                message.status = 500;
                                
                            break;
                    }
                ]]>
            </method>
        </behavior>
    </handler>

    <handler path="/quit">
        <behavior>
            <method id="onInvoke" params="content, message">
                <![CDATA[
                    getBehavior().handleShellQuit( message );
                ]]>
            </method>
        </behavior>
    </handler>
    
    <handler path="/diagnostics">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    message.responseText = JSON.stringify( getBehavior().getDiagnostics() );
                ]]>
            </method>
        </behavior>
    </handler>
    
    <handler path="/logs">
        <behavior like="AuthenticatedDebugHandlerMessageBehavior">
            <method id="processMessage" params="handler, message, params">
                <![CDATA[
                    if( params.contains( "list" ) )
                    {
                        var result = new Object();
                        var logPath = getBehavior().getLogFilePath();
                        
                        result.path = logPath;
                        result.logs = [];

                        if( logPath != null && Files.exists( logPath ) )
                        {
                            var iterator = new Files.Iterator( logPath );
                            var extension = ".log";
                            var info = null;
                            var path;
                            
                            while( info = iterator.getNext() )
                            {
                                if( info.path.indexOf( extension, info.path.length - extension.length ) != -1 )
                                    result.logs.push( info.path );
                            }
                        }
                        
                        message.responseText = JSON.stringify( result );
                    }
                    else if( params.contains( "path" ) )
                    {
                        var logPath = getBehavior().getLogFilePath();
                        var logFile = mergeURI( logPath, params.getValue( "path" ) );
                        
                        if( Files.exists( logFile ) == "file" )
                            message.responsePath = logFile;
                    }
                ]]>
            </method>
        </behavior>
    </handler>
    
</module>
