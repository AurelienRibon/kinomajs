<!--
|     Copyright (C) 2010-2015 Marvell International Ltd.
|     Copyright (C) 2002-2010 Kinoma, Inc.
|
|     Licensed under the Apache License, Version 2.0 (the "License");
|     you may not use this file except in compliance with the License.
|     You may obtain a copy of the License at
|
|      http://www.apache.org/licenses/LICENSE-2.0
|
|     Unless required by applicable law or agreed to in writing, software
|     distributed under the License is distributed on an "AS IS" BASIS,
|     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
|     See the License for the specific language governing permissions and
|     limitations under the License.
-->
<module xmlns="http://www.kinoma.com/kpr/1">

    <require id="BUTTONS" path="controls/buttons"/>
    <require id="SLIDERS" path="controls/sliders"/>
    <require id="SWITCH" path="controls/switch"/>
    <require id="ROUND_SLIDER" path="controls/round-slider"/>
    <require id="SCROLLER" path="mobile/scroller"/>
    <require id="SAMPLEGRAPH" path="creations/sampleGraph"/>

    <skin id="whiteSkin" color="white"/>
    <skin id="blackSkin" color="black"/>
    <skin id="redSkin" color="red"/>
    <skin id="yellowSkin" color="yellow"/>
    <skin id="blueSkin" color="blue"/>
    
    <content id="Background" left="0" top="0" right="0" bottom="0" skin="whiteSkin"/>

    <class id="AxisDescription">
		<constructor params="json"><![CDATA[
            this.applyField(json, "ioType");
            this.applyField(json, "dataType");
            this.applyField(json, "valueLabel");
            this.applyField(json, "valueID");
            this.applyField(json, "value");
            this.applyField(json, "speed");
            this.applyField(json, "defaultControl");
         ]]></constructor>
        <method id="applyField" params="json, fieldName"> <![CDATA[
        	if (fieldName in json)	this[fieldName] = json[fieldName]
         ]]></method>
		
		<field id="ioType" value="0" />									<!-- [input | output] -->
		<field id="dataType" value="0" />								<!-- [float, boolean] later: enum, floatArray, booleanArray -->
		<field id="valueLabel" value="0" />								<!-- value display name -->
		<field id="valueID" value="0" />								<!-- name of value property in data -->
		<field id="minValue" value="0" />								<!-- minimum value -->
		<field id="maxValue" value="1" />								<!-- maximum value -->
		<field id="value" value="0" />									<!-- starting value -->
		<field id="speed" value="5"/>									<!-- starting speed (hertz) -->
		<field id="defaultControl" value="0"/>							<!-- index of default popup control -->
    </class>
    
    <class id="BooleanAxisDescription" like="AxisDescription"> 
		<constructor params="json"><![CDATA[
            AxisDescription.call(this, json);
         ]]></constructor>
		<field id="dataType" value="'boolean'" />							
		<field id="defaultControl" value="SQUARE_GENERATOR"/>
     </class>
    
    <class id="DigitalInputAxisDescription" like="BooleanAxisDescription"> 
		<constructor params="json"><![CDATA[
            BooleanAxisDescription.call(this, json);
         ]]></constructor>
		<field id="ioType" value="'input'"/>
		<field id="minValue" value="0"/>
		<field id="maxValue" value="1"/>
		<field id="defaultControl" value="BUTTON"/>
     </class>
    
    <class id="DigitalOutputAxisDescription" like="BooleanAxisDescription"> 
		<constructor params="json"><![CDATA[
            BooleanAxisDescription.call(this, json);
         ]]></constructor>
		<field id="ioType" value="'output'"/>
		<field id="minValue" value="0"/>
		<field id="maxValue" value="1"/>
     </class>
    
    <class id="FloatAxisDescription" like="AxisDescription">
    	<constructor params="json"><![CDATA[
            AxisDescription.call(this, json);
            this.applyField(json, "minValue");
            this.applyField(json, "maxValue");
            this.applyField(json, "rangeMinValue");
            this.applyField(json, "rangeMaxValue");
        ]]></constructor>
		<field id="dataType" value="'float'" />							
		<field id="defaultControl" value="SINE_GENERATOR"/>
        <field id="rangeMinValue" value="0"/>
        <field id="rangeMaxValue" value="0"/>
    </class>

    <class id="AnalogInputAxisDescription" like="FloatAxisDescription"> 
		<constructor params="json"><![CDATA[
            FloatAxisDescription.call(this, json);
         ]]></constructor>
		<field id="ioType" value="'input'"/>
		<field id="minValue" value="0"/>
		<field id="maxValue" value="1"/>
     </class>
    
    <class id="AnalogOutputAxisDescription" like="FloatAxisDescription"> 
		<constructor params="json"><![CDATA[
            FloatAxisDescription.call(this, json);
         ]]></constructor>
		<field id="ioType" value="'output'"/>
		<field id="minValue" value="0"/>
		<field id="maxValue" value="1"/>
     </class>
    
    <content id="DragGroupButton" top="0" left="0">
        <behavior>
            <method id="onCreate" params="container, data"> <![CDATA[
                container.variant = data.variant;
             ]]></method>        
        </behavior>
    </content>

    <behavior id="DragButtonGroupBehavior">
        <field id="buttonValue" value="''"/>
        
        <method id="hitButton" params="button, x, y"><![CDATA[
            return (x <= button.x + button.width && x >= button.x && y <= button.y + button.height && y >= button.y)
         ]]></method>
        
        <method id="touchButtons" params="container, x, y"><![CDATA[
            var content = container.first;
            var hitButton = null;
            while (content) {
                var hit = this.hitButton(content, x, y);
                if (hit)
                    hitButton = content;
                content.state = hit ? 2 : 1;
                content = content.next;
            }
            return hitButton;
        ]]></method>
        
        <method id="onOpenTouch" params="container, id, x, y, ticks"><![CDATA[
        	this.downButton = this.touchButtons(container, x, y);
        ]]></method>
        
        <method id="onTouchMoved" params="container, id, x, y, ticks"><![CDATA[
            this.touchButtons(container, x, y);
        ]]></method>
        
        <method id="onTouchEnded" params="container, id, x, y, ticks"><![CDATA[
            var hitButton = this.touchButtons(container, x, y);
            if (hitButton && (hitButton !== this.downButton)) {
                this.onButtonSelected(container, hitButton.variant);
				var content = container.first;
				while (content) {
					content.state = 1;
					content = content.next;
				}
			}
        ]]></method>
        
        <method id="onButtonSelected" params="container, variant"/>
    </behavior>
    
    
    <!-- 
            Wave Generators
            
            Generate various parametric waveforms
    -->
    
    <class id="WaveGenerator">
    
        <field id="rangeMin" value="0"/>              
        <field id="rangeMax" value="1"/>                      

       <constructor params="rangeMin, rangeMax"><![CDATA[
            this.rangeMin = rangeMin;
            this.rangeMax = rangeMax;
         ]]></constructor>
         
        <method id="start" params="time"><![CDATA[
            this.startTime = time;
        ]]></method>
        
        <method id="timeToFraction" params="time"><![CDATA[
            var dt = time - this.startTime;
            var fraction = dt / 1000;
            if (false == (fraction <= 1))
                fraction = fraction - Math.floor(fraction);
            return fraction;
        ]]></method>

        <method id="applyRange" params="value"><![CDATA[
        	var scale = this.rangeMax - this.rangeMin;
        	var min = lerp(-1, 1, this.rangeMin)
        	var max = lerp(-1, 1, this.rangeMax)
        	var offset = lerp(min, max, 0.5);
    		var rangedValue = (scale * value) + offset;
           	return rangedValue;
        ]]></method>
               
       <method id="normalizedValueForFraction" params="fraction"/>      <!-- subclasses override this -->
   </class>
    
    <class id="SineWaveGenerator" like="WaveGenerator">
        <field id="twoPI" value="2 * Math.PI"/>
        
        <method id="normalizedValueForFraction" params="fraction"><![CDATA[
            var value = this.valueForFraction(fraction)
 			value = this.applyRange(value);
            return value;
         ]]></method>
         
       <method id="valueForFraction" params="fraction"><![CDATA[
            return Math.sin(fraction * this.twoPI);
         ]]></method>
    </class>
    
    <class id="TriangleWaveGenerator" like="WaveGenerator">
        <field id="twoPI" value="2 * Math.PI"/>
        
        <method id="normalizedValueForFraction" params="fraction"><![CDATA[
            var amplitude = 1;
            var normalizedValue = ((2 * amplitude) / Math.PI) * Math.asin( Math.sin( this.twoPI * fraction ) );
            normalizedValue = this.applyRange(normalizedValue);
            return normalizedValue;
        ]]></method>
    </class>
    
    <class id="SquareWaveGenerator" like="WaveGenerator">
        
        <method id="normalizedValueForFraction" params="fraction"><![CDATA[
            var normalizedValue = 2 * (2 * Math.floor(fraction) - Math.floor(2 * fraction) + 0.5);
            normalizedValue = this.applyRange(normalizedValue);
            return normalizedValue;
         ]]></method>
    </class>
    
    
    <!-- Utility Functions -->
    
    <function id="lerp" params="from, to, fraction"><![CDATA[
        return from + fraction * (to - from);
    ]]></function>
    
    <function id="toFraction" params="value, minValue, maxValue"><![CDATA[
        return value / (maxValue - minValue);
    ]]></function>
    
    
    <!-- 
            WaveDrawer
    -->
    
    <class id="WaveDrawer">
        
        <constructor params="canvas"><![CDATA[
            this.canvas = canvas;
            this.hertzAdjustOffset = 0;
            this.polled = 0;
        ]]></constructor>

        <method id="updateWaveform" params="waveGenerator, numCycles"><![CDATA[
            var canvas = this.canvas;
            var canvasHeight = canvas.height;
            var waveWidth = this.waveWidth = Math.floor(canvas.width / numCycles);
            var yValues = new Array(numCycles * waveWidth);
            var normalizedValues = new Array(numCycles * waveWidth);
            for (var cycle = 0; cycle < numCycles; cycle++) {
                for (var i=0; i < waveWidth; i++) {
                    var index = (cycle * waveWidth) + i;
                    var fraction = i / waveWidth;
                    var value = waveGenerator.normalizedValueForFraction(fraction);
                    normalizedValues[index] = value;
                    value = (value / 2) + 0.5;      // from [-1,1] to [0,1]
                    value *= (canvasHeight - 4);
                    value += 2;     
                    value = canvasHeight - value;   // origin is at top
                    yValues[index] = value;
                }
            }       
            this.yValues = yValues;     
            this.normalizedValues = normalizedValues;   
        ]]></method>

        <method id="draw" params="phaseFraction"><![CDATA[
            this.drawBackground();
            this.drawCenterLine();
            this.drawWaveform(phaseFraction);
            this.polled--;
            if (this.polled < 0)
            	polled = 0;
        ]]></method>

        <method id="setHertzAdjustOffset" params="hertzAdjustOffset"><![CDATA[
        	var length = this.yValues.length;
        	var offset = (hertzAdjustOffset + length) % length;
            this.hertzAdjustOffset = offset;
        ]]></method>

        <method id="getPhaseStartIndex" params="phaseFraction"><![CDATA[
            return Math.round(phaseFraction * this.waveWidth);
        ]]></method>

        <method id="getNormalizedValueForPhaseFraction" params="phaseFraction"><![CDATA[
            var sampleIndex = this.getPhaseStartIndex(phaseFraction);
            return this.normalizedValues[sampleIndex];
        ]]></method>
		
       <method id="drawBackground"><![CDATA[
            var canvas = this.canvas;
            var ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#EEEEEE";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        ]]></method>

       <method id="drawWaveform" params="phaseFraction"><![CDATA[
            var yValues = this.yValues;
            var canvas = this.canvas;
            var ctx = canvas.getContext("2d");
            ctx.lineWidth = 1;
            ctx.strokeStyle =  "#000000";
            ctx.beginPath();
            var startIndex = this.getPhaseStartIndex(phaseFraction);
            startIndex += this.hertzAdjustOffset;
            startIndex = (startIndex + yValues.length) % yValues.length;
            var x = -1;
            ctx.moveTo(x, yValues[startIndex]);
            for (var i=startIndex, c=yValues.length; i<c; i++) {
                x++;
                ctx.lineTo(x, yValues[i]);
            }
            for (var i=0; i < startIndex; i++) {
                x++;
                ctx.lineTo(x, yValues[i]);
            }
            ctx.stroke();
        ]]></method>
       
       <method id="drawCenterLine"><![CDATA[
            var canvas = this.canvas;
            var ctx = canvas.getContext("2d");
            ctx.strokeStyle = (this.polled > 0) ? "yellow" : "#AAAAAA";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();   
        ]]></method>
    </class>

    <texture id="thinDividerTexture" small="assets/one-pixel-divider.png"/>
    <skin id="thinDividerSkin" texture="thinDividerTexture" x="0" y="0" width="24" height="5" aspect="fill">
        <tiles left="2" right="2"/>
    </skin> 
    
    <content id="ThinDivider" top="0" left="0" right="0" height="5" skin="thinDividerSkin">
        <behavior>
            <method id="onDisplaying" params="content"><![CDATA[
                var root = content.container.container;					//* try using anchor here
                if (content.container === root.last)
                    content.visible = false;
            ]]></method>
        </behavior>
    </content>
        
    <texture id="thickDividerTexture" small="assets/three-pixel-divider.png"/>
    <skin id="thickDividerSkin" texture="thickDividerTexture" x="0" y="0" width="24" height="5" aspect="fill">
        <tiles left="2" right="2"/>
    </skin> 

    <content id="ThickDivider" top="0" left="20" right="0" height="5" skin="thickDividerSkin"/>
    
    <texture id="popupTexture" large="assets/popup-background.png"/>
    <skin id="popupSkin" texture="popupTexture" x="0" y="0" width="10" height="10" aspect="fill">
        <tiles left="2" right="2" top="2" bottom="2"/>
    </skin>
        
    <texture id="waveformsTexture" large="assets/sinewave-strip-48h-80w.png"/>
    <skin id="waveformSkin" texture="waveformsTexture" x="0" y="0" width="50" height="24">
        <variants offset="50" names="SINE_GENERATOR,TRIANGLE_GENERATOR,SQUARE_GENERATOR,CUSTOM_GENERATOR,BUTTON,SLIDER"/>
        <states offset="24"/>
    </skin>
        
    <variable id="SENSOR_GUAGE" value="5"/>								<!-- so we don't break apps that used the original misspelled version -->
    <texture id="sensorTexture" large="assets/sensor-strip.png"/>
    <skin id="sensorSkin" texture="sensorTexture" x="0" y="0" width="40" height="40" aspect="fill">
        <variants offset="40" names="SENSOR_BUTTON,SENSOR_KNOB,SENSOR_LED,SENSOR_SLIDER,SENSOR_MODULE,SENSOR_GAUGE,SENSOR_SERIAL"/>
    </skin>
    
    <style id="largeHeaderTextStyle" font="bold 24px" align="left" color="red"/>
    <style id="smallHeaderTextStyle" font="bold 14px" align="left" color="gray"/>
    
    <texture id="turndownArrowTexture" large="assets/small-toggles-strip.png"/>
    <skin id="turndownArrowSkin" texture="turndownArrowTexture" x="0" y="0" width="14" height="14" aspect="draw">
        <variants offset="14" names="TURNDOWN_CLOSED,TURNDOWN_OPEN"/>
        <states offset="14"/>
    </skin>
    
    <style id="valueLabelStyle" font="16px" align="right" color="black"/>
    <style id="valueTextStyle" font="bold 22px" align="left" color="black"/>

    <container id="InputAxisValueLine" top="0" left="0" height="30" width="360-20-40">
        <line name="line" top="0" left="0" height="30">
            <container name="turndown" left="-10" top="0" width="30" bottom="0" active="true" skin="turndownArrowSkin" variant="TURNDOWN_OPEN">
                <behavior like="BUTTONS.ToggleButtonBehavior">
                    <field id="name" value="'TurndownArrowButton'"/>
                    <field id="selectedVariant" value="TURNDOWN_OPEN"/>
                    <field id="unselectedVariant" value="TURNDOWN_CLOSED"/>
                    
                    <method id="onSelected" params="container"><![CDATA[
                        var axisContainer = container.container.container.container;
                        axisContainer.behavior.onTurndownSelected(axisContainer);
                    ]]></method>
                    <method id="onUnselected" params="container"><![CDATA[
                        var axisContainer = container.container.container.container;
                        axisContainer.behavior.onTurndownUnselected(axisContainer);
                    ]]></method>
                </behavior>         
            </container>
            <label top="0" left="0" height="30" style="valueLabelStyle" string="$.valueLabel"/>
            <content left="0" top="0" height="30" width="10"/>
            <label name="valueLabel" top="0" left="0" height="30" style="valueTextStyle" string="$.value"/>
        </line>
        <scope with="$.waveMenuButton">
            <container right="0" top="0" like="WaveMenuButton"/>
        </scope>
    </container>
	
	<skin id="levelMeterBackgroundSkin" color="#eeeeee"/>
	
    <container id="OutputAxisValueLine" top="0" left="0" height="30 + 50" width="360-20-40">
        <line name="line" top="0" left="0" height="30">
            <label top="0" left="0" height="30" style="valueLabelStyle" string="$.valueLabel"/>
            <content left="0" top="0" height="30" width="10"/>
            <label name="valueLabel" top="0" left="0" height="30" style="valueTextStyle" string="$.value"/>
		</line>
 
 		<content left="0" right="0" top="30" height="50" skin="levelMeterBackgroundSkin"/>
    	<container name="levelMeter" like="SAMPLEGRAPH.LevelMeterWithProbe" left="0" right="0" top="30" height="50"/>
   </container>
    
    <behavior id="PartColumnBehavior">  
        <field id="defaultIconVariant" />
        <method id="onCreate" params="column, data"><![CDATA[
            this.column = column;
            this.defaultIconVariant = data.header.iconVariant;

            var axesColumn = new Column( { left : 0, right : 0, top : 0, bottom : undefined });
            axesColumn.name = "axesColumn";
            axesColumn.behavior = new PartBehavior(axesColumn, data);
            this.axesColumn = axesColumn;
            column.partContentsContainer.add(axesColumn);  
        ]]></method>
        <method id="getID" params="column"><![CDATA[
            return this.axesColumn.delegate("getID");
        ]]></method>
        
        <method id="getValue" params="column"><![CDATA[
            return this.axesColumn.delegate("getValue");
        ]]></method>
        <method id="setValue" params="column, valueID, value"><![CDATA[
            this.axesColumn.delegate("setValue", valueID, value);
        ]]></method>
        <method id="setIconTexture" params="column, texture"><![CDATA[  
            var icon = this.column.header.icon;
            if( texture == null )
            {
                icon.skin = sensorSkin;
                icon.variant = this.defaultIconVariant;
            }
            else 
            {        
	            var iconSkin = new Skin(texture, { x : 0, y : 0, width : texture.width, height : texture.height });
	            icon.skin = iconSkin;
	            icon.variant = 0;
	        }
        ]]></method>
    </behavior>

    <behavior id="BaseInputAxisContainerBehavior">
        <method id="addAxisValue" params="column, result"><![CDATA[
            result[this.data.valueID] = this.currentValue;                    
            this.column.distribute("onValuePolled");
        ]]></method>
        <method id="onCreate" params="column, data, menuButton"><![CDATA[
            this.data = data;
            this.column = column;
            this.currentValue = 0;
            this.currentRangeMinValue = data.hasOwnProperty("rangeMinValue") ? data.rangeMinValue : data.minValue;
            this.currentRangeMaxValue = data.hasOwnProperty("rangeMaxValue") ? data.rangeMaxValue : data.maxValue;
            this.currentValue = data.hasOwnProperty("value") ? data.value : this.currentRangeMinValue;
            this.currentHertzValue = data.hasOwnProperty("speed") ? data.speed : 2.5;
          ]]></method>    
         <method id="setAxisRange" params="column, rangeMinValue, rangeMaxValue"><![CDATA[
            this.currentRangeMinValue = rangeMinValue;
            this.currentRangeMaxValue = rangeMaxValue;
        ]]></method>                 
        <method id="setAxisHertz" params="column, value"><![CDATA[
            this.currentHertzValue = value;                   
        ]]></method>
         <method id="getAxisContainer" params="column"><![CDATA[
            return column;
        ]]></method>
    </behavior>
        
    <column id="InputAxisContainer" name="axisContainer" top="0" clip="true" left="0" right="0">
        <behavior like="BaseInputAxisContainerBehavior">
            <method id="addAxisValue" params="column, result"><![CDATA[
                result[this.data.valueID] = this.currentValue;                    
                this.column.distribute("onValuePolled");
                this.axisValueLine.line.valueLabel.string = this.currentValue.toString().substring(0, 6);
            ]]></method>
            <method id="onCreate" params="column, data, menuButton"><![CDATA[
            	BaseInputAxisContainerBehavior.prototype.onCreate.call(this, column, data, menuButton);
                this.lastManualValue = undefined;
                this.currentHertzValue = "speed" in data ? data.speed : 2.5;
      			var menuButtonData = { };
      			
                switch (data.dataType) {
                    case "boolean":
                        menuButtonData.buttonVariants = [SQUARE_GENERATOR,BUTTON];
                        menuButtonData.selection = data.defaultControl;
                    break
                    case "float":
                        menuButtonData.buttonVariants = [SINE_GENERATOR,TRIANGLE_GENERATOR,SQUARE_GENERATOR,SLIDER];
                        menuButtonData.selection = data.defaultControl;
                    break
                }
                data.waveMenuButton = menuButtonData;
        
                var axisValueLine = new InputAxisValueLine(data);
                this.axisValueLine = axisValueLine;
                column.add(axisValueLine);
                                            
                this.onControlSelected(column, menuButtonData.selection);           // add initial editor
            ]]></method>    
			<method id="onControlSelected" params="column, variant"><![CDATA[
                this.selectedVariant = variant;
                if (column.length > 1)
                    column.remove(column.last);
                if (variant == BUTTON || variant == SLIDER)
                    this.addManualControl(column);
                else if (variant == CUSTOM_GENERATOR)
                    this.addCustomControl(column);
                else
                    this.addWaveformControl(column, variant);
                    
    //          this.axisValueLine.line.turndown.variant = "TURNDOWN_OPEN";
                this.axisValueLine.line.turndown.variant = 1;
            ]]></method>
            <method id="onTurndownSelected" params="column"><![CDATA[
                this.onControlSelected(column, this.selectedVariant);
            ]]></method>
            <method id="onTurndownUnselected" params="column"><![CDATA[
                if (column.length > 1) {
                    column.last.height = 0;
                    column.last.visible = false;
                }
            ]]></method>
            <method id="addManualControl" params="column"><![CDATA[
                var initialValue = this.lastManualValue != undefined ? this.lastManualValue : this.data.value;
                switch (this.data.dataType) {
                    case "boolean":
                        var toggleButton = new ValueSwitchButton( { value : initialValue } );
                        column.add(toggleButton);
                    break
                    case "float":
                        var valueSlider = new ValueSlider( { min : this.data.minValue, max : this.data.maxValue, value : initialValue } );
                        column.add(valueSlider);    
                    break
                }                       
            ]]></method>
            <method id="addCustomControl" params="column"><![CDATA[
            //  var customControlLabel = new
            ]]></method>        
            <method id="addWaveformControl" params="column, variant"><![CDATA[
            	var data = this.data;
                var editorData = {
                    dataType : this.data.dataType,
                    waveVariant : variant,
                    rangeSlider : { min : data.minValue, max : data.maxValue,
                    				rangeMinValue : this.currentRangeMinValue, rangeMaxValue : this.currentRangeMaxValue },           
                    hertzSlider : { min : 0, max : 5, value : this.currentHertzValue }
                };
                var waveformEditor = new WaveformEditor(editorData);
                column.add(waveformEditor);         
            ]]></method>
            <method id="onNormalizedControlValueChanged" params="column, value"><![CDATA[
                value = (value / 2) + 0.5;
                value = lerp(this.data.minValue, this.data.maxValue, value);
                this.onControlValueChanged(column, value, false);
            ]]></method>                            
            <method id="onControlValueChanged" params="column, value, updateLabel"><![CDATA[
 				var axisContainer = column.container;
				this.currentValue = value;
				if (updateLabel)
					this.axisValueLine.line.valueLabel.string = this.currentValue.toString().substring(0, 6);
			]]></method>
        </behavior>
    </column>

    <behavior id="BaseOutputAxisContainerBehavior">
        <method id="setAxisValue" params="column, valueID, value"><![CDATA[
			if (this.data.valueID == valueID) {
		//		this.data[valueID].value = value;
				this.data[valueID] = value;
				column.distribute("onOutputValueChanged", value);
			}
        ]]></method>
        <method id="onCreate" params="column, data"><![CDATA[
            this.data = data;
            this.column = column;
            this.currentValue = 0;
            this.currentRangeMinValue = data.hasOwnProperty("rangeMinValue") ? data.rangeMinValue : data.minValue;
            this.currentRangeMaxValue = data.hasOwnProperty("rangeMaxValue") ? data.rangeMaxValue : data.maxValue;
            this.currentHertzValue = data.hasOwnProperty("speed") ? data.speed : 2.5;
          ]]></method>    
         <method id="getAxisContainer" params="column"><![CDATA[
            return column;
        ]]></method>
    </behavior>
        
    <column id="OutputAxisContainer" name="axisContainer" top="0" clip="true" left="0" right="0">
        <behavior like="BaseOutputAxisContainerBehavior">
            <method id="addAxisValue" params="column, result"><![CDATA[
                result[this.data.valueID] = this.currentValue;                    
                this.axisValueLine.line.valueLabel.string = this.currentValue.toString().substring(0, 6);
            ]]></method>
            <method id="onCreate" params="column, data, menuButton"><![CDATA[
            	BaseOutputAxisContainerBehavior.prototype.onCreate.call(this, column, data, menuButton);
            	data.probeOffset = -10;										// for SAMPLEGRAPH.LevelMeterWithProbe
                var axisValueLine = new OutputAxisValueLine(data);
                this.axisValueLine = axisValueLine;
                column.add(axisValueLine);
                this.currentValue = 0;			
                column.start();
            ]]></method>                 
             <method id="onTimeChanged" params="column"><![CDATA[
                this.onOutputValueChanged(column, this.currentValue);
            ]]></method>
            <method id="getAxisContainer" params="column"><![CDATA[
                return column;
            ]]></method>
            <method id="onOutputValueChanged" params="column, value"><![CDATA[
 				var axisContainer = column.container;
				this.currentValue = value;
				this.axisValueLine.line.valueLabel.string = this.currentValue.toString().substring(0, 6);
				this.axisValueLine.levelMeter.distribute("onMeterLevelChanged",this.currentValue); 
			]]></method>
        </behavior>
    </column>

   <!-- 
   		BasePartBehavior
   		
   		May be subclassed to create a Custom Controller for all axis of a Part
   		    			
   			getID(column)				
   			setValue(column, value)		sets all axis values from json value
   			getValue(column)			return json with values for all axis
   -->
     
   <behavior id="BasePartBehavior">
      <method id="onCreate" params="column, data"> <![CDATA[
      		this.data = data;
      		// instantiate your UI here
       ]]></method>
       
		<method id="getID" params="column"><![CDATA[
			return this.data.id;
        ]]></method>
        
		<method id="getValue" params="column"><![CDATA[
            // return json structure with all axis values here
        ]]></method>
        
        <method id="setValue" params="column, valueID, value"><![CDATA[
            // set all axis values based on json value
        ]]></method>
   </behavior>
   
   <behavior id="PartBehavior" like="BasePartBehavior">
       <method id="onCreate" params="column, data"> <![CDATA[
       		BasePartBehavior.prototype.onCreate.call(this, column, data);
			var axes = data.axes
			for (var i=0; i < axes.length; i++) {
				var axisData = axes[i];
				if (axisData.ioType == "input") {
					var childColumn = new Column( { left : 20, top : 0, right : 0, bottom : undefined } );	
					var axisContainer = new InputAxisContainer(axes[i]);
					
					childColumn.add(axisContainer);
					childColumn.add( new ThinDivider() );
					column.add(childColumn);
				}
				else if (axisData.ioType == "output") {
					var childColumn = new Column( { left : 20, top : 0, right : 0, bottom : undefined } );	
					axisContainer = new OutputAxisContainer(axes[i]);
					childColumn.add(axisContainer);
					childColumn.add( new ThinDivider() );
					column.add(childColumn);
				}
			} 
       ]]></method>
       
		<method id="getValue" params="column"><![CDATA[
           var result = {};
            for (var i=0; i < column.length; i++) {
                var axisColumn = column.content(i);
                var axisContainer = axisColumn.axisContainer;
                axisContainer.delegate("addAxisValue", result);
            }
            return result;
        ]]></method>
        
        <method id="setValue" params="column, valueID, value"><![CDATA[
            for (var i=0; i < column.length; i++) {
                var axisColumn = column.content(i);
                var axisContainer = axisColumn.axisContainer;
                axisContainer.delegate("setAxisValue", valueID, value);
            }
        ]]></method>
   </behavior>
   
   <!-- 
   		PartColumnBehavior dynamically creates column with PartBehavior (or custom behavior subclassing BasePartBehavior)
   		and inserts as child of partContentsContainer
   	-->
   
    <column id="PartColumn" top="0" left="0" width="360-20" behavior="'behavior' in $ ? $.behavior : PartColumnBehavior">
        <scope with="$.header">
            <container name="header" top="0" left="0" right="0" height="50">
                <content name="icon" top="10" left="10" width="40" height="40" skin="sensorSkin" variant="$.iconVariant"/>
                <label top="8" left="54" right="10" height="30" string="$.label" style="largeHeaderTextStyle"/>
                <label top="28" left="54" right="10" height="30" string="$.name" style="smallHeaderTextStyle"/>
            </container>
        </scope>
        
        <column name="partContentsContainer" top="0" left="20" right="0">		<!-- containes value line, waveforms -->
        </column>
        
        <content like="ThickDivider"/>
    </column>
    
    <content id="WaveformDragGroupButton" top="0" left="0" state="1" skin="waveformSkin" like="DragGroupButton"/>
    
    <container id="WaveButtonGroup" left="0" right="0" top="0" bottom="0" active="true">
        <behavior like="BUTTONS.ButtonBehavior">
            <method id="onTouchBegan" params="container, id, x, y, ticks"><![CDATA[
               container.container.remove(container);
            ]]></method>
        </behavior>
		<column name="popup" active="true" skin="popupSkin">
			<behavior like="DragButtonGroupBehavior">
				<method id="onCreate" params="column, data"><![CDATA[
					var variantsArray = data.buttonVariants
					for (var i=0, c=variantsArray.length; i < c; i++) {
						var buttonVariant = variantsArray[i];
						var button = new WaveformDragGroupButton( { variant : buttonVariant } );
						button.state = (buttonVariant == data.selection) ? 2 : 1;
						column.add( button );
					 }
				]]></method>
				<method id="onButtonSelected" params="column, variant"><![CDATA[
					this.menuButton.behavior.onButtonSelected(this.menuButton, variant);
				]]></method>
			</behavior>
		</column>
    </container>
    
    <texture id="menuDownTexture" large="assets/menu-down.png"/>
    <skin id="menuDownSkin" texture="menuDownTexture" x="0" y="0" width="10" height="10"/>

    <container id="WaveMenuButton" width="50" height="24" skin="waveformSkin" exclusiveTouch="true" like="BUTTONS.Button">
        <content left="0" width="10" height="10" skin="menuDownSkin"/>
        <behavior like="BUTTONS.ButtonBehavior">
            <method id="onCreate" params="container, data"><![CDATA[
                BUTTONS.ButtonBehavior.prototype.onCreate.call(this, container, data);
                container.variant = data.selection;
                container.state = 1;
                this.data = data;
            ]]></method>
            <method id="onDisplaying" params="content">
                <![CDATA[
                    var parent = content;
                    while( parent.container != null )
                       parent = parent.container;
                    this.rootContainer = parent;
                    this.waveButtonGroup = null;
                ]]>
            </method>
            <method id="onUndisplayed" params="content">
                <![CDATA[
                	if (this.waveButtonGroup)
						this.rootContainer.remove(this.waveButtonGroup);
                ]]>
            </method>
            <method id="onTouchBegan" params="container, id, x, y, ticks"><![CDATA[
				var waveButtonGroup = this.waveButtonGroup = new WaveButtonGroup(this.data);
                waveButtonGroup.popup.behavior.menuButton = container;
                var menuHeight = 24 * waveButtonGroup.length;
                var selectionIndex = this.getSelectionIndex(waveButtonGroup.popup, this.data.selection);

                var yOffset = 24 * -selectionIndex;
                var top = container.y - this.rootContainer.y + yOffset;
                var bottom = top + menuHeight;
                var appBottom = this.rootContainer.y + this.rootContainer.height;
                if (top < 0)
                    top = 0;
                else if (bottom > appBottom)
                    top = appBottom - menuHeight; 
                waveButtonGroup.popup.coordinates = { left : container.x - this.rootContainer.x, top : top };

                this.rootContainer.add(waveButtonGroup);
                
            	this.waveButtonGroup.popup.delegate("onOpenTouch", id, x, y, ticks);
            ]]></method>
            <method id="onTouchMoved" params="container, id, x, y, ticks"><![CDATA[
            	this.waveButtonGroup.popup.delegate("onTouchMoved", id, x, y, ticks);
            ]]></method>
            <method id="onTouchEnded" params="container, id, x, y, ticks"><![CDATA[
            	this.waveButtonGroup.popup.delegate("onTouchEnded", id, x, y, ticks);
            ]]></method>
            <method id="getSelectionIndex" params="buttonGroup, selection"><![CDATA[
                for (var i=0; i < buttonGroup.length; i++) {
                    var button = buttonGroup.content(i);
                    if (button.variant == selection)
                        return i;
                }       
                return -1;
            ]]></method>
            <method id="onButtonSelected" params="container, variant"><![CDATA[
                this.rootContainer.remove(this.rootContainer.last);
                container.variant = variant;
                this.data.selection = variant;          
                var controlSwitcher = container.container.container;
                controlSwitcher.behavior.onControlSelected(controlSwitcher, variant);           
            ]]></method>
        </behavior>
    </container>

    <canvas id="HertzSlider" width="120" height="60" active="true">
        <behavior like="ROUND_SLIDER.RoundSliderBehavior"><![CDATA[
	        function onTouchBegan(container, id, x, y, ticks) {
	            ROUND_SLIDER.RoundSliderBehavior.prototype.onTouchBegan.call(this, container, id, x, y, ticks);
                var waveGenerator = container.container.first;
	        }
	        function onTouchEnded(container, id, x, y, ticks) {
	            ROUND_SLIDER.RoundSliderBehavior.prototype.onTouchEnded.call(this, container, id, x, y, ticks);
                var waveGenerator = container.container.first;
			}
           function onValueChanged(container) {
                ROUND_SLIDER.RoundSliderBehavior.prototype.onValueChanged.call(this, container);
                var waveGenerator = container.container.first;
                var data = this.data;
                var value = data.value;
                /*
                var nonLinear = false
                if (nonLinear) {
	                var fraction = value / (data.max - data.min);
	                fraction = Math.sineEaseIn(fraction);
	                value = lerp(data.min, data.max, fraction);
	            }
	            */
                waveGenerator.behavior.setHertz(value);
    	       	container.bubble("setAxisHertz", value);           
            }
            function getStrokeStyle(active) {
                return active ? "#fc5720" : "#515153";
            }
            function getLabel() {
                return "Hertz";
            }
        ]]></behavior>
    </canvas>

    <behavior id="ValueSliderBehavior" like="SLIDERS.SliderBehavior"><![CDATA[
        function onTouchBegan(container, id, x, y, ticks) {
            container.captureTouch(id, x, y, ticks);
            this.onTouchMoved(container, id, x, y, ticks);
        }
        function onTouchEnded(container, id, x, y, ticks) {
        }
        function onTouchMoved(canvas, id, x, y, ticks) {
            var size = canvas.width;
            var offset = (x - canvas.x);
            this.setOffset(canvas, size, offset);
            this.onValueChanged(canvas);
        }
        function onAxisValueChanged(canvas, value) {
        	this.data.value = value;
        	this.onValueChanged(canvas);
        }
        function onValueChanged(canvas) {
            var active = canvas.active;
            
            var knobWidth = 6;
            var halfKnobWidth = knobWidth / 2;
            var knobHeight = 20;
            var inset = 8;
            var width = canvas.width - (2 * inset);
            var offset = this.getOffset(canvas, width);
            
            var ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = active ? "#458ccb" : "#515153";
            ctx.strokeStyle = active ? "#458ccb" : "#515153";
            var sliderBarHeight = 4;
            var sliderBarTop = (canvas.height / 2) - (sliderBarHeight / 2);
            ctx.strokeRect(0, sliderBarTop, canvas.width, sliderBarHeight);
            ctx.fillRect(inset + offset + halfKnobWidth, sliderBarTop, canvas.width - offset + halfKnobWidth, sliderBarHeight);

            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(inset + offset - knobWidth / 2, 0, knobWidth, knobHeight - 1);
            ctx.strokeRect(inset + offset - knobWidth / 2, 0, knobWidth, knobHeight - 1);
        }
    ]]></behavior>
        
    <container id="ValueSlider" left="0" right="0" top="0" height="30">
        <canvas width="240" height="20" active="true">
            <behavior like="ValueSliderBehavior"><![CDATA[
                function onValueChanged(container) {
                    ValueSliderBehavior.prototype.onValueChanged.call(this, container);
                    var axisContainer = container.container.container;              
                    axisContainer.behavior.lastManualValue = this.data.value;   
                    axisContainer.behavior.onControlValueChanged(axisContainer, this.data.value, true);
                }
            ]]></behavior>
        </canvas>
    </container>
    
    <container id="ValueSwitchButton" like="SWITCH.SwitchButton">
        <behavior like="SWITCH.SwitchButtonBehavior">
            <method id="onValueChanged" params="container, value"><![CDATA[
                SWITCH.SwitchButtonBehavior.prototype.onValueChanged.call(this, container, value);
                var axisContainer = container.container;                                    
                axisContainer.behavior.lastManualValue = this.data.value;                       
                axisContainer.behavior.onControlValueChanged(axisContainer, this.data.value, true);
            ]]></method>
        </behavior>
    </container>

    <container id="WaveformEditor" top="0" left="0" right="0" height="100">
        <behavior>
            <method id="onCreate" params="container, data"> <![CDATA[
                this.data = data;
            ]]></method>
        </behavior>
        
        <canvas name="waveGenerator" top="0" left="0" right="0" height="50">
            <behavior>
                <method id="onCreate" params="canvas, data, context"><![CDATA[
                    this.data = data;
                    this.canvas = canvas;
                    this.waveVariant = data.waveVariant;
                    this.hertz = 1;
                    this.hertzAdjustOffset = 0;
                ]]></method>
                
                <method id="getPhaseFraction" params="canvas"><![CDATA[
                    return ((canvas.time * this.hertz) % 1000) / 1000;
                ]]></method>
                
                <method id="getPhaseFractionForHertz" params="canvas, hertz"><![CDATA[
                    return ((canvas.time * hertz) % 1000) / 1000;
                ]]></method>
                
                <method id="onDisplaying" params="canvas"><![CDATA[
                    canvas.interval = 0;                                     
                    canvas.time = 0;
                    var axisContainer = canvas.bubble("getAxisContainer");
                    var rangeMinValue = axisContainer.behavior.currentRangeMinValue;
                    var rangeMaxValue = axisContainer.behavior.currentRangeMaxValue;
                    switch (this.waveVariant) {
                        case SINE_GENERATOR:
                            this.waveGenerator = new SineWaveGenerator(rangeMinValue, rangeMaxValue);
                        break
                        case TRIANGLE_GENERATOR:
                            this.waveGenerator = new TriangleWaveGenerator(rangeMinValue, rangeMaxValue);
                        break
                        case SQUARE_GENERATOR:
                            this.waveGenerator = new SquareWaveGenerator(rangeMinValue, rangeMaxValue);
                        break
                    }
                    this.waveGenerator.start(0);
                    
                    var waveDrawer = this.waveDrawer = new WaveDrawer(canvas, this);
                    var phaseFraction = this.getPhaseFraction(canvas);
                    waveDrawer.updateWaveform(this.waveGenerator, 4);
                    waveDrawer.draw(phaseFraction);
                    
                    if (this.data.dataType == "boolean") {
                        canvas.container.rangeSlider.visible = false;
                        canvas.container.hertzSlider.coordinates = { top : 50, width : 120, height : 60 };
                    }
                        
                    canvas.time = 0;
                    canvas.start();
                ]]></method>
                
                <method id="onTimeChanged" params="canvas"><![CDATA[       
                    var phaseFraction = this.getPhaseFraction(canvas);
                    this.waveDrawer.draw(phaseFraction);
                    this.sampleValue(canvas);
                 ]]></method>          
        
                <method id="onValuePolled" params="canvas"><![CDATA[ 
                    if( "waveDrawer" in this )   
                        this.waveDrawer.polled = 8;
                 ]]></method>          
        
                <method id="sampleValue" params="canvas"><![CDATA[       
                    var phaseFraction = this.getPhaseFraction(canvas);
                    var sampledValue = this.waveDrawer.getNormalizedValueForPhaseFraction(phaseFraction);
                    var axisContainer = canvas.container.container;
                    axisContainer.behavior.onNormalizedControlValueChanged(axisContainer, sampledValue);
                    return sampledValue;
                ]]></method>          
              
                <method id="setRange" params="rangeMin, rangeMax"><![CDATA[       
                    this.waveGenerator.rangeMin = rangeMin;
                    this.waveGenerator.rangeMax = rangeMax;
                    this.waveDrawer.updateWaveform(this.waveGenerator, 4);
                 ]]></method>          
                
                <method id="getPixelOffset" params="hertz"><![CDATA[       
                    var phaseFraction = this.getPhaseFractionForHertz(this.canvas, hertz);
                    return this.waveDrawer.getPhaseStartIndex(phaseFraction);
                 ]]></method>          
		      
                <method id="setHertz" params="hertz"><![CDATA[
                	if (hertz != this.hertz) {
                		var previousOffset = this.getPixelOffset(this.hertz);
                		var newOffset = this.getPixelOffset(hertz);
                		var delta = previousOffset - newOffset;
                		this.hertzAdjustOffset += delta;
                		this.waveDrawer.setHertzAdjustOffset(this.hertzAdjustOffset);
                    	this.hertz = hertz;  
                    } 
                  ]]></method>   
            </behavior>
        </canvas>
        
        <scope with="$.rangeSlider">
            <canvas name="rangeSlider" top="50" left="10" width="120" like="ROUND_SLIDER.RangeSlider"/>
        </scope>
        <scope with="$.hertzSlider">
            <canvas name="hertzSlider" top="50" right="10" width="120" like="HertzSlider"/>
        </scope>
    </container>
        
	<scroller id="PartsScroller" like="SCROLLER.VerticalScroller" clip="true">
 		<behavior like="SCROLLER.VerticalScrollerBehavior">
            <method id="onCreate" params="scroller, data">
                <![CDATA[
                	SCROLLER.VerticalScrollerBehavior.prototype.onCreate.call(this, scroller, data);
                	if (undefined != data && data.hasOwnProperty("parts")) {
	                    var parts = data.parts;
	                    var partsContainer = scroller.partsContainer;
	                    for (var i=0; i < parts.length; i++)
	                    	this.addPart(scroller, parts[i]);
	            	}
                ]]>
            </method>
            <method id="addPart" params="scroller, data">
                <![CDATA[
                	var partColumn = new PartColumn(data);
                	scroller.partsContainer.add(partColumn);
                	return partColumn;
                ]]>
            </method>
            <method id="setPartValue" params="scroller, partID, value">
                <![CDATA[
                    var partColumn = this.getPartColumn(scroller, partID);
                    if (partColumn != null)
                    	partColumn.delegate("setValue", value);
                ]]>
            </method>
            <method id="getPartValue" params="scroller, partID">
                <![CDATA[
                    var partColumn = this.getPartColumn(scroller, partID);
                    if (partColumn != null)
                    	return partColumn.delegate("getValue");
                    return null;
                ]]>
            </method>
            <method id="setPartIconTexture" params="scroller, partID, iconTexture">
                <![CDATA[
                    var partColumn = this.getPartColumn(scroller, partID);
                    if (partColumn != null)
                    	partColumn.delegate("setIconTexture", iconTexture);
                ]]>
            </method>
            <method id="getPartColumn" params="scroller, partID">
                <![CDATA[
         			var partsContainer = scroller.partsContainer;
                    for (var i=0; i < partsContainer.length; i++) {
                    	var partColumn = partsContainer.content(i);
                    	var anID = partColumn.delegate("getID");
                    	if (anID == partID)
                    		return partColumn;
                    }
                    return null;
                ]]>
            </method>
        </behavior>
      	<column name="partsContainer" top="0" left="0" right="0"/>
         <content left="0" top="0" right="0" height="1000"/>
		<content like="SCROLLER.VerticalScrollbar"/>
		<content like="SCROLLER.TopScrollerShadow"/>
		<content like="SCROLLER.BottomScrollerShadow"/>
	</scroller>
	
    <script><![CDATA[
       var gAdjustingHertz = false;
    ]]></script>
</module>
