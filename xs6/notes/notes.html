<html>

<head>
<title>XS 6 Development Notes</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" href="./highlight/styles/xcode.css">
<script src="./highlight/highlight.pack.js"></script>
<style>

a, div, h1, h2, h3, h4, h5, h6, li, ol, p table, tr , td {
	font-family: Arial, Helvetica, Geneva, sans-serif;
}

body {
	margin-left: 30px;
	margin-right: 30px;
}

#TITLE {
	counter-reset:section;
	font-size: 300%;
	margin-bottom: 20px;
}
a {
	text-decoration: none;
}
.L1, .L2 {
	display:block;
	padding-top: 2px;
	padding-bottom: 2px;
}
.L1 {
	counter-reset: subsection;
	margin-left: 10px;
}
.L1:before {
	counter-increment:section;
	content:counter(section) ". ";
}
.L2 {
	display:block;
	font-size: 80%;
	margin-left: 20px;
}
.L2:before {
	counter-increment: subsection;
	content:counter(section) "." counter(subsection) ". ";
}
#BEGIN {
	counter-reset:section;
}
h1 {
	border-top: solid #383838 1px;
	font-weight: normal;
	margin-top: 20px;
	margin-bottom: 5px;
	padding-top: 5px;
}
h1:before {
	counter-increment:section;
	content:counter(section) ". ";
}
.SECTION {
	counter-reset:subsection;
}
h2 {
	border-top: solid #383838 1px;
	font-weight: normal;
	margin-top: 20px;
	margin-bottom: 5px;
	padding-top: 5px;
}
h2:before {
	counter-increment:subsection;
	content:counter(section) "." counter(subsection) ". ";
}
h3 {
	font-style: italic;
	font-weight: normal;
	margin-top: 10px;
	margin-bottom: 0px;
}


pre {
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 20px;
	margin-right: 20px;
}

table {
	border-collapse: collapse;
}
tr {
}
td {
	background-color: #f0f0f0;
	border: solid white 1px;
	padding-left: 5px;
	padding-right: 5px;
	padding-top: 2px;
	padding-bottom: 2px;
}
.NUMBER {
	text-align: right;
}
.BEST {
	font-weight: bold;
}
.RESULT {
	margin-left: 20px;
	margin-bottom: 10px;
}
.RESULT span {
	background-color: #e0e0e0;
	color: #383838;
	padding-left: 5px;
	padding-right: 5px;
	padding-top: 2px;
	padding-bottom: 2px;
}
.MAIN {
	line-height: 20px;
	margin-top: 10px;
	margin-bottom: 10px;
}
p {
	line-height: 20px;
	margin-top: 10px;
	margin-bottom: 10px;
}
.CODE {
	font-family: monospace;
	font-size: 120%;
}
</style>

<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>

<div id="TITLE">XS 6 Development Notes</div>

<a href="#Introduction" class="L1">Introduction</a>
<a href="#Examples" class="L1">Examples</a>
<a href="#Literals" class="L2">Literals</a>
<a href="#Symbols" class="L2">Symbols</a>
<a href="#Variables" class="L2">Variables</a>
<a href="#Bindings" class="L2">Bindings</a>
<a href="#Arguments" class="L2">Arguments</a>
<a href="#Classes" class="L2">Classes</a>
<a href="#Objects" class="L2">Objects</a>
<a href="#Reflection" class="L2">Reflection</a>
<a href="#Arrows" class="L2">Arrows</a>
<a href="#Generators" class="L2">Generators</a>
<a href="#Promises" class="L2">Promises</a>
<a href="#Modules" class="L2">Modules</a>
<a href="#Architecture" class="L1">Architecture</a>
<a href="#Separation" class="L2">Separation</a>
<a href="#Passes" class="L2">Passes</a>
<a href="#Platform" class="L2">Platform</a>
<a href="#XS_in_C" class="L2">XS in C</a>
<a href="#Sandbox" class="L2">Sandbox</a>
<a href="#Source_Maps" class="L2">Source Maps</a>
<a href="#XML" class="L2">XML</a>
<a href="#Strict" class="L2">Strict</a>
<a href="#Performances" class="L1">Performances</a>

<div id="BEGIN"></div>
<a id="Introduction"><h1>Introduction</h1></a>
<div class="SECTION">

<p>
There have been no version numbers for XS. But now it seems easy to number them according to the version of ECMAScript they are trying to implement.
</p><p>
This document mostly presents the examples I used to test XS 6 while I was modifying the parser, byte code compiler and runtime.
Each example covers new features of ECMAScript 6 with some comments.
The development is based on the
<a href="https://people.mozilla.org/~jorendorff/es6-draft.html">draft</a>
that has been released on Christmas Eve.
</p><p>
At the end there are some details about the architecture and the performances. 
</p>

</div>
<a id="Examples"><h1>Examples</h1></a>
<div class="SECTION">

<p>
In the examples, the gray boxes are the output of <span class="CODE">console.log</span>.
</p>

<a id="Literals"><h2>Literals</h2></a>

<pre><code class="javascript">// binary and octal
var b = 0b1011101;
var d = 93;
var o = 0o135;
var x = 0x5D;
console.log(b, d, o, x);
</code></pre>
<pre class="RESULT"><span>93 93 93 93</span></pre>

<pre><code class="javascript">// 32-bit unicode escape
console.log("\u{1F061}")
</code></pre>
<pre class="RESULT"><span style="font-size: 300%;">üÅ°</span></pre>

<pre><code class="javascript">// multiline strings
var s = `Every character
 matters.`
console.log(s);
</code></pre>
<pre class="RESULT"><span>Every character</span>
<span> matters.</span></pre>

<pre><code class="javascript">// template strings
var name = "Jane";
var s = `Hello ${name}, today is ${new Date().toDateString()}.`
console.log(s);
</code></pre>
<pre class="RESULT"><span>Hello Jane, today is 2015/01/24.</span></pre>

<a id="Symbols"><h2>Symbols</h2></a>

<pre><code class="javascript">// unique symbols without description
var sym0 = Symbol();
console.log(sym0);
var sym1 = Symbol();
console.log(sym1);
</code></pre>
<pre class="RESULT"><span>Symbol()</span>
<span>Symbol()</span></pre>

<pre><code class="javascript">// unique symbols with description
var sym2 = Symbol("key");
console.log(sym2);
var sym3 = Symbol("key");
console.log(sym3);
</code></pre>
<pre class="RESULT"><span>Symbol("key")</span>
<span>Symbol("key")</span></pre>

<pre><code class="javascript">// global symbols
var sym4 = Symbol["for"]("key");
console.log(sym4, Symbol.keyFor(sym4));
var sym5 = Symbol["for"]("key");
console.log(sym5, Symbol.keyFor(sym5));
</code></pre>
<pre class="RESULT"><span>Symbol("key") key</span>
<span>Symbol("key") key</span></pre>

<pre><code class="javascript">// sym4 == sym5, "key" is no symbol
var object = {};
object[sym0] = 0;
object[sym1] = 1;
object[sym2] = 2;
object[sym3] = 3;
object[sym4] = 4;
object[sym5] = 5;
object["key"] = 6;
console.log(object[sym0], object[sym1], object[sym2], object[sym3], object[sym4], object[sym5], object["key"]);
</code></pre>
<pre class="RESULT"><span>0 1 2 3 5 5 6</span></pre>

<pre><code class="javascript">console.log(typeof sym0);
</code></pre>
<pre class="RESULT"><span>symbol</span></pre>

<pre><code class="javascript">// no new
try { eval(`
	var sym = new Symbol
`)} catch(e) { console.log(e); }
</code></pre><pre class="RESULT"><span>TypeError</span></pre>

<a id="Variables"><h2>Variables</h2></a>

<pre><code class="javascript">// block scoped variable and constant
var v = 0;
let l = 0;
const c = 0;
{
	var v = 1;
	let l = 1;
	const c = 1;
	console.log(v, l, c);
}
console.log(v, l, c);
</code></pre><pre class="RESULT"><span>1 1 1</span>
<span>1 0 0</span></pre>

<pre><code class="javascript">// can set const only once
try { eval(`
	{
		const r = 0;
		r = 1;
	}
`)} catch(e) { console.log(e); }
</code></pre><pre class="RESULT"><span>TypeError</span></pre>

<pre><code class="javascript">// can declare var multiple times
// can declare let and const only once by block
try { eval(`
	{
		var v;
		var v;
		let l;
		let l;
	}
`)} catch(e) { console.log(e); }
try { eval(`
	{
		let v;
		var v;
	}
`)} catch(e) { console.log(e); }
try { eval(`
	function f(a) {
		let a;
	}
`)} catch(e) { console.log(e); }
</code></pre><pre class="RESULT"><span>SyntaxError</span>
<span>SyntaxError</span>
<span>SyntaxError</span></pre>

<pre><code class="javascript">// can use var before declaration
// cannot use let and const before declaration
try { eval(`
	{
		v = 1;
		l = 1;
		var v;
		let l;
	}
`)} catch(e) { console.log(e); }
</code></pre><pre class="RESULT"><span>SyntaxError</span></pre>

<pre><code class="javascript">// blocks share var
var array = [];
for (var i = 0; i < 3; i++) {
	array[i] = function() { return i; }
}
array = array.map(f => f());
console.log(array);
</code></pre><pre class="RESULT"><span>3,3,3</span></pre>

<pre><code class="javascript">// blocks create let and const
var array = [];
for (let i = 0; i < 3; i++) {
	array[i] = function() { return i; }
}
array = array.map(f => f());
console.log(array);
</code></pre><pre class="RESULT"><span>0,1,2</span></pre>

<a id="Binding"><h2>Bindings</h2></a>

<pre><code class="javascript">// de-structuring array, skip and rest
var array = [1,2,3,4,5,6];
var [a, , b, ...c] = array;
console.log("a:", a, "b:", b, "c:", c);
</code></pre><pre class="RESULT"><span>a: 1 b: 3 c: 4,5,6</span></pre>

<pre><code class="javascript">// default value and fail safe
var array = [1,2];
var [a, b, c = 3, d] = array;
console.log("a:", a, "b:", b, "c:", c, "d:", d);
</code></pre><pre class="RESULT"><span>a: 1 b: 2 c: 3 d: undefined</span></pre>

<pre><code class="javascript">// de-structuring object
var object = { x: 0, y: 1, z: 2 };
var { x, y, z } = object;
console.log("x:", x, "y:", y, "z:", z);
</code></pre><pre class="RESULT"><span>x: 0 y: 1 z: 2</span></pre>

<pre><code class="javascript">// default value and fail safe
var object = { x: 0 };
var { x, y = 2, z } = object;
console.log("x:", x, "y:", y, "z:", z);
</code></pre><pre class="RESULT"><span>x: 0 y: 2 z: undefined</span></pre>

<pre><code class="javascript">// nested
var object = { 
	last: "Doe", 
	members: [ 
		{ first: "Jane" }, 
		{ first: "John" } 
	] 
};
var { 
	last: x, 
	members: [ 
		{ first: y }, 
		{ first: z }
	] 
} = object;
console.log("x:", x, "y:", y, "z:", z);
</code></pre><pre class="RESULT"><span>x: Doe y: Jane z: John</span></pre>

<a id="Arguments"><h2>Arguments</h2></a>
<pre><code class="javascript">// default value
function f1(x, y = 6) {
	console.log("f1( x:", x, "y:", y, ")");
}
f1(7, 8);
f1(5);
</code></pre><pre class="RESULT"><span>f1( x: 7 y: 8 )</span>
<span>f1( x: 5 y: 6 )</span></pre>

<pre><code class="javascript">// rest
function f2(x, ...y) {
	console.log("f2( x:", x, "y:", y, ")");
}
f2(1,2,3,4,5,6);
</code></pre><pre class="RESULT"><span>f2( x: 1 y: 2,3,4,5,6 )</span></pre>

<pre><code class="javascript">// spread
var array = [1,2,3,4,5,6];
f2(...array);
</code></pre><pre class="RESULT"><span>f2( x: 1 y: 2,3,4,5,6 )</span></pre>

<pre><code class="javascript">// de-structuring array
function f3([a, , b, ...c]) {
	console.log("f3( a:", a, "b:", b, "c:", c, ")");
}
f3([1,2,3,4,5,6]);
</code></pre><pre class="RESULT"><span>f3( a: 1 b: 3 c: 4,5,6 )</span></pre>

<pre><code class="javascript">// de-structuring object
function f4({ x, y, z }) {
	console.log("f4( x:", x, "y:", y, "z:", z, ")");
}
f4({ x: 0, y: 1, z: 2 });
</code></pre><pre class="RESULT"><span>f4( x: 0 y: 1 z: 2 )</span></pre>

<a id="Classes"><h2>Classes</h2></a>

<pre><code class="javascript">class X {
	constructor(it) { 
		this._x = it 
	}
	get it() { 
		return this._x;
	}
	set it(x) { 
		this._x = x;
	}
	increment() { 
		this.it++;
	}
	zero() { 
		this._x = 0 
	}
}
class Y extends X {
	constructor(it) { 
		super(it);
		this._y = it; 
	}
	get it() { 
		return super.it;
	}
	set it(x) { 
		super.it = x;
		this._y = x; 
	}
	zero() { 
		super.zero();
		this._y = 0; 
	}
}
var x = new X(6);
var y = new Y(6);
console.log("x", JSON.stringify(x));
console.log("y", JSON.stringify(y));
</code></pre><pre class="RESULT"><span>x {"_x":6}</span>
<span>y {"_x":6,"_y":6}</span></pre>

<pre><code class="javascript">x.increment();
y.increment();
console.log("x", JSON.stringify(x));
console.log("y", JSON.stringify(y));
</code></pre><pre class="RESULT"><span>x {"_x":7}</span>
<span>y {"_x":7,"_y":7}</span></pre>

<pre><code class="javascript">x.zero();
y.zero();
console.log("x", JSON.stringify(x));
console.log("y", JSON.stringify(y));
</code></pre><pre class="RESULT"><span>x {"_x":0}</span>
<span>y {"_x":0,"_y":0}</span></pre>

<pre><code class="javascript">class Z extends Y {
	// default constructor
}
var z = new Z(6);
console.log("z", JSON.stringify(z));
</code></pre><pre class="RESULT"><span>z {"_x":6,"_y":6}</span></pre>

<a id="Objects"><h2>Objects</h2></a>

<pre><code class="javascript">// shortcut
var foo = "foo"
var o1 = {
	foo,
};
console.log(JSON.stringify(o1));
</code></pre><pre class="RESULT"><span>{"foo":"foo"}</span></pre>

<pre><code class="javascript">// computed property name
var o2 = {
    [ 'property' + Math.round(100 * Math.random()) ]: foo
};
console.log(JSON.stringify(o2));
</code></pre><pre class="RESULT"><span>{"property100":"foo"}</span></pre>

<pre><code class="javascript">// method
var o3 = {
	toString() {
		return "o3 " + super.toString();
    },
};
console.log(o3);
</code></pre><pre class="RESULT"><span>o3 [object Object]</span></pre>

<a id="Reflection"><h2>Reflection</h2></a>

<pre><code class="javascript">var target = {
	stressed: 0,
	redrawer: 0,
};
var handler = {
  get: function(target, key) {
    return Reflect.get(target, key.split("").reverse().join(""));
  },
  set: function(target, key, value) {
  	Reflect.set(target, key.split("").reverse().join(""), value);
  }
};
var proxy = new Proxy(target, handler);
console.log("target.stressed:", target.stressed);
console.log("proxy.desserts:", proxy.desserts);
</code></pre><pre class="RESULT"><span>target.stressed: 0</span>
<span>proxy.desserts: 0</span></pre>

<pre><code class="javascript">proxy.rewarder = 1;
console.log("target.redrawer:", target.redrawer);
console.log("proxy.rewarder:", proxy.rewarder);
</code></pre><pre class="RESULT"><span>target.redrawer: 1</span>
<span>proxy.rewarder: 1</span></pre>

<a id="Arrows"><h2>Arrows</h2></a>

<pre><code class="javascript">// expression body
var evens = [0, 2, 4, 6, 8, 10, 12, 14];
var odds = evens.map(v => v + 1);
console.log(odds);
</code></pre><pre class="RESULT"><span>1,3,5,7,9,11,13,15</span></pre>

<pre><code class="javascript">// statement body
var fives = [];
odds.forEach(v => {
  if (v % 5 === 0)
    fives.push(v);
});
console.log(fives);
</code></pre><pre class="RESULT"><span>5,15</span></pre>

<pre><code class="javascript">// lexical this
var bob = {
  _name: "Bob",
  _friends: [ "Jane", "Joe" ],
  printFriends: function() {
    this._friends.forEach(f =>
      console.log(this._name + " knows " + f));
  }
}
bob.printFriends();
</code></pre><pre class="RESULT"><span>Bob knows Jane</span>
<span>Bob knows Joe</span></pre>

<a id="Generators"><h2>Generators</h2></a>

<pre><code class="javascript">function* fibonacci(limit) {
	var former = 0, current = 1;
	for (;;) {
		var temporary = former;
		former = current;
		current += temporary;
		if (current > limit)
			return;
		yield current;
    }
}
var f = fibonacci(6)
for(;;) {
	let result = f.next();
	if (result.done)
		break;
	console.log(result.value);
}
</code></pre><pre class="RESULT"><span>1</span>
<span>2</span>
<span>3</span>
<span>5</span></pre>

<pre><code class="javascript">// for of
var g = fibonacci(6)
for (var n of g)
	console.log(n);
</code></pre><pre class="RESULT"><span>1</span>
<span>2</span>
<span>3</span>
<span>5</span></pre>
	
<pre><code class="javascript">// spread
var h = fibonacci(6)	
console.log(...h);
</code></pre><pre class="RESULT"><span>1 2 3 5</span></pre>
	
<pre><code class="javascript">// yield expression
function* twice(limit) {
	var current = 1;
	while (current < limit)
		current = 2 * yield current;
}
var f2 = twice(10)
for (let former = 1;;) {
	let result = f2.next(former);
	if (result.done)
		break;
	former = result.value;
	console.log(former);
}
</code></pre><pre class="RESULT"><span>1</span>
<span>2</span>
<span>4</span>
<span>8</span></pre>

<a id="Promises"><h2>Promises</h2></a>

<pre><code class="javascript">// log with timestamp
var start = Date.now();
function timestamp(...args) {
 	console.log(Math.round((Date.now() - start) / 250) * 250, ...args);
}

// promises based on setTimeout 
class TimeoutPromise extends Promise {
	constructor(duration, argument) {
		super((resolve, reject) => {
			setTimeout(resolve, duration, argument);
		})
	}
}

timestamp("begin");
</code></pre><pre class="RESULT"><span>0 begin</span></pre>
<pre><code class="javascript">var p = new TimeoutPromise(1000).then(
	result => {
		timestamp("TimeoutPromise resolved with", result);
</code></pre><pre class="RESULT"><span>1000 TimeoutPromise resolved with undefined</span></pre>
<pre><code class="javascript">		timestamp("Promise.all");
</code></pre><pre class="RESULT"><span>1000 Promise.all</span></pre>
<pre><code class="javascript">		return Promise.all([
			new TimeoutPromise(250, "one"), 
			new TimeoutPromise(1000, "two"), 
			new TimeoutPromise(500, "three")
		]);
	}
).then(
	result => {
		// the result of Promise.all is the array of the results of all resolved promises
		timestamp("Promise.all resolved with", result);
</code></pre><pre class="RESULT"><span>2000 Promise.all resolved with one,two,three</span></pre>
<pre><code class="javascript">		timestamp("Promise.race");
</code></pre><pre class="RESULT"><span>2000 Promise.race</span></pre>
<pre><code class="javascript">		return Promise.race([
			new TimeoutPromise(250, "one"), 
			new TimeoutPromise(1000, "two"), 
			new TimeoutPromise(500, "three")
		]);
	}
).then(
	result => {
		// the result of Promise.race is the result of the first resolved promise
		timestamp("Promise.race resolved with", result);
</code></pre><pre class="RESULT"><span>2250 Promise.race resolved with one</span></pre>
<pre><code class="javascript">		timestamp("Promise.resolve");
</code></pre><pre class="RESULT"><span>2250 Promise.resolve</span></pre>
<pre><code class="javascript">		return Promise.resolve("wow");
	}
).then(
	result => {
		timestamp("then resolved with", result);
</code></pre><pre class="RESULT"><span>2250 then resolved with wow</span></pre>
<pre><code class="javascript">		timestamp("Promise.reject");
</code></pre><pre class="RESULT"><span>2250 Promise.reject</span></pre>
<pre><code class="javascript">		return Promise.reject("oops");
	}
).then( 
	null,
	reason => {
		timestamp("then rejected with", reason);
</code></pre><pre class="RESULT"><span>2250 then rejected with oops</span></pre>
<pre><code class="javascript">		timestamp("returning");
</code></pre><pre class="RESULT"><span>2250 return</span></pre>
<pre><code class="javascript">		return "wow";
	}
).then( 
	result => {
		timestamp("then returned", result);
</code></pre><pre class="RESULT"><span>2250 then returned wow</span></pre>
<pre><code class="javascript">		timestamp("throwing");
</code></pre><pre class="RESULT"><span>2250 throw</span></pre>
<pre><code class="javascript">		throw "oops";
	}
)["catch"]( 
	reason => {
		timestamp("then threw", reason);
</code></pre><pre class="RESULT"><span>2250 then threw oops</span></pre>
<pre><code class="javascript">		timestamp("catching");
</code></pre><pre class="RESULT"><span>2250 catching</span></pre>
<pre><code class="javascript">	}
).then( 
	result => {
		timestamp("end");
</code></pre><pre class="RESULT"><span>2250 end</span></pre>
<pre><code class="javascript">	}
);
</code></pre>

<a id="Modules"><h2>Modules</h2></a>

<h3>lib.js</h3>
<pre><code class="javascript">// named exports
export const sqrt = Math.sqrt;
export function square(x) {
	return x * x;
}
export function diag(x, y) {
	return sqrt(square(x) + square(y));
}

// default export
export default class { 
	constructor(x, y) {
		this.x = x;
		this.y = y;
	}
	diag() {
		return sqrt(square(this.x) + square(this.y));
	}
};

// export references, not values
export let counter = 0;
export function increment() {
	counter++;
}
</code></pre>

<h3>main.js</h3>

<pre><code class="javascript">// named imports
import { square, diag } from 'lib';
console.log(square(11));
console.log(diag(4, 3));
</code></pre><pre class="RESULT"><span>121</span>
<span>5</span></pre>

<pre><code class="javascript">// default import
import Point from 'lib';
var p = new Point(5, 12);
console.log(p.diag());
</code></pre><pre class="RESULT"><span>13</span></pre>

<pre><code class="javascript">// import references, not values
import { increment, counter } from 'lib';
console.log(counter);
increment();
console.log(counter);
</code></pre><pre class="RESULT"><span>0</span>
<span>1</span></pre>

<pre><code class="javascript">// renamed import
import { square as sq, diag as hypo } from 'lib';
console.log(sq(11));
console.log(hypo(4, 3));
</code></pre><pre class="RESULT"><span>121</span>
<span>5</span></pre>

<pre><code class="javascript">// import all as properties
import * as lib from 'lib';
console.log(lib.square(11));
console.log(lib.diag(4, 3));
</code></pre><pre class="RESULT"><span>121</span>
<span>5</span></pre>

<pre><code class="javascript">// still references
lib.increment();
console.log(lib.counter);
</code></pre><pre class="RESULT"><span>2</span></pre>

<h3>A.js</h3>
<pre><code class="javascript">import { B_a as A_B_a } from "B";
import { c as A_c } from "C";
export var a = "A_a";
export { A_B_a as A_B_a_1 };
export { A_B_a as A_B_a_2 };
export { b } from "B"
</code></pre>
<h3>B.js</h3>
<pre><code class="javascript">export { a as B_a } from "A"
export { c } from "C"
export { d } from "D"
export var b = "B_b";
</code></pre>
<h3>C.js</h3>
<pre><code class="javascript">export * from "D";
export var c = "C_c";
</code></pre>
<h3>D.js</h3>
<pre><code class="javascript">export * from "A";
export var d = "D_d";
</code></pre>
<h3>main.js</h3>
<pre><code class="javascript">// circularity
import * as A from "A";
import * as B from "B";
import * as C from "C";
import * as D from "D";
for (var id in A)
	console.log("A exports", A[id], "as", id);
for (var id in B)
	console.log("B exports", B[id], "as", id);
for (var id in C)
	console.log("C exports", C[id], "as", id);
for (var id in D)
	console.log("D exports", D[id], "as", id);
</code></pre><pre class="RESULT"><span>A exports A_a as A_B_a_2</span>
<span>A exports A_a as A_B_a_1</span>
<span>A exports A_a as a</span>
<span>A exports B_b as b</span>
<span>B exports B_b as b</span>
<span>B exports D_d as d</span>
<span>B exports C_c as c</span>
<span>B exports A_a as B_a</span>
<span>C exports C_c as c</span>
<span>C exports D_d as d</span>
<span>C exports A_a as A_B_a_2</span>
<span>C exports A_a as A_B_a_1</span>
<span>C exports A_a as a</span>
<span>C exports B_b as b</span>
<span>D exports D_d as d</span>
<span>D exports A_a as A_B_a_2</span>
<span>D exports A_a as A_B_a_1</span>
<span>D exports A_a as a</span>
<span>D exports B_b as b</span></pre>

</div>
<a id="Architecture"><h1>Architecture</h1></a>
<div class="SECTION">

<p>
There are a few things I did not want to change because a lot of C code, in XS itself, but also in KPR for instance, relies on them: exceptions, slots, stack frames, etc.
</p><p>
Except for that, I allowed myself to change everything that needed to change: new parser and compiler, new byte codes, new run loop, etc.
</p>

<a id="Separation"><h2>Separation</h2></a>
<p>
In XS 6, the byte code compiler is separate from the virtual machine runtime: 
</p><ul>
<li>Severely constrained hosts can use the runtime alone and load only byte code files.</li>
<li>Other hosts can load, parse and compile text files asynchronously.</li>
</ul><p>
Parsing and compiling scripts use neither slots not chunks anymore. 
Parsing and compiling creates a lot of records that can be deleted as soon as the byte code is produced but only then,
which is an unnecessary burden for a garbage collector.
</p><p>
The separation allowed me to build a significantly more complex parser and byte code compiler.
Mostly because of ECMAScript 6, but also because I wanted to improve the way XS handles closures and modules, 
</p>

<a id="Passes"><h2>Passes</h2></a>
<p>
The  byte code compiler user four passes:
</p><ul>
<li>The lexical and syntactical parser builds a syntax tree.</li>
<li>The syntax tree is firstly traversed to hoist classes, functions and variables.</li>
<li>Then the syntax tree is traversed to bind accesses and assignments.</li>
<li>Then byte codes are compiled.</li>
</ul><p>
The  main idea is that everything that can be found at compile time should not be searched at run time.
</p><p>
The syntax tree uses tables to dispatch the four passes specifically for each kind of syntax token.
</p>

<a id="Platform"><h2>Platform</h2></a>
<p>
ECMAScript 6 requires two asynchronous jobs queues: one for promises, one for modules.
</p><h3>Promises</h3><p>
Even when the executor of a promise is synchronous, the resolution of a promise is always asynchronous to its execution.
</p><pre><code class="javascript">var promise = new Promise((resolve, reject) => {
	console.log("one");
	resolve("three");
}).then(result => {
	console.log(result);
});
console.log("two");
</code></pre><pre class="RESULT"><span>one</span>
<span>two</span>
<span>three</span></pre><p>
XS 6 manages the promises jobs queue since promises jobs contain roots for the garbage collector. However the way jobs are scheduled is determined by the platform. The only constraint is of course that jobs of a virtual machine must be executed by the same thread that is running the virtual machine.
</p><h3>Modules</h3><p>
ECMAScript 6 wants to reconcile the different ways modules are used today in JavaScript. Currently KPR loads module with a synchronous
<span class="CODE">require</span> function. But for modules to work in browsers, they need to be loaded asynchronously and that is what ECMAScript 6 specifies.
</p><p>
XS 6 defers the loading of module to the platform. Since the byte code compiler is separate from the virtual machine runtime, the process can be completely asynchronous until the script is ready to be executed. Then the platform callbacks the virtual machine.
</p><p>
Notice that loading a module can triggers several exchanges between the virtual machine and the platforms since all interdependent modules need to be loaded together.
</p>

<a id="XS_in_C"><h2>XS in C</h2></a>
<p>
The C programming interface of XS will not change.
What will change is the way native features are made available to scripts.
</p><p>
ECMAScript does not have a syntax to define native features. XS used to provide them thru XML files, the so-called grammar files:
</p><h3>KPR.xs</h3>
<pre><code class="xml">&lt;package&gt;
	&lt;function name="parseURI" params="url" c="KPR_parseURI"/&gt
&lt;/package&gt
</code></pre><p>
XS  transformed grammar files into specific byte code and C files which make native features available to scripts 
</p><p>
I do not want such an essential mechanism to depend on XML anymore, but I do not want to extend ECMAScript... What I propose is to adopt the conventions of node.js. Modules can be defined in JavaScript or in C but not both. 
</p><p>
In C, modules defines a function that XS calls to get native features.
</p><h3>KPR.c</h3>
<pre><code class="c">void xsHostModule(xsMachine* the) {
	xsNewHostProperty(xsResult, xsID("parseURI"), xsNewHostFunction(KPR_parseURI, 1));
}
</code></pre><p>
Then JavaScript modules can import such features as usual.
</p>
<h3>main.js</h3>
<pre><code class="javascript">import parseURI from "KPR";
</code></pre><p>
</p><p>
Since there are no specific mechanisms, the programming interface of XS could be ported to other languages than C. So native features could also be defined in other language than C.
</p><p>
Thanks to KPR, most of our platform is in C now, so such an evolution should be easy enough. To implement an extension in C and JavaScript, just split the extension into two modules. The JavaScript module would use the ECMAScript 6 syntax to re-export all or some of the native features.
</p>
</p><h3>foo.c</h3>
<pre><code class="c">void xsHostModule(xsMachine* the) {
	xsNewHostProperty(xsResult, xsID("foo"), xsNewHostFunction(foo, 1));
}
</code></pre>
<h3>goo.js</h3>
<pre><code class="javascript">// re-export all
export * from "foo";
</code></pre><p>
I will enhance XS2JS to help our current extensions to evolve. 
</p>

<a id="Sandbox"><h2>Sandbox</h2></a>
<p>
In 2012, in the KPR Development Notes, I explained the difference between the XS sandbox and modules. The intent was already to move away from the "two-faced" sandbox and to build programming interfaces with modules.
</p><p>
Now:</p><ul>
<li>We use KPR for all our projects.</li>
<li>ECMAScript 6 specifies a flexible architecture for modules.</li> 
<li>XS 6 is especially optimized for modules.</li>
</ul><p>
So I propose that we eventually get rid of the sandbox. It is a non-standard mechanism that is just annoying us here and there. 
</p>

<a id="Source_Maps"><h2>Source Maps</h2></a>
<p>
Because of browsers, there are several languages that can be transformed into JavaScript, like CoffeeScript or TypeScript.
</p><p>
To make it possible to debug the original source code, the preprocessors generate both Javascript source code and <a href="https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit">source maps</a>. 
</p><p>
XS can now uses such source maps too. Instead of the generated JavaScript source code, the original source code is displayed, stepped, etc, in XSBUG.   
</p><p>
XS 6 defers the loading of the source map to the platform since it can be asynchronous. The platform callbacks the byte code compiler when the source map is ready.
</p>

<a id="XML"><h2>XML</h2></a>
<p>
I removed the XML part of XS from XS 6 and will provide its features in a module. The intent is of course to reduce the footprint of XS 6 since XML is less and less needed by applications.
</p><p>
JSON is now the favorite data format for the communication between servers and clients, for manifest and preferences files, etc. We still use a few XML files here and there but it should be easy enough to get rid of them.
</p><p>
The XML programming interface of KPR is in fact a "language" that is transformed into JavaScript, like CoffeeScript or TypeScript. Its preprocessor is KPR2JS. By itself the XML programming interface of KPR does not require XML features in the runtime.
</p>

<a id="Strict"><h2>Strict</h2></a>
<p>
Modules always use the strict mode of ECMAScript. Since applications and shells will be modules, it means the end of the "sloppy" mode in our JavaScript code.
</p><p>
Essentially it helps since common programming errors are reported earlier. The main constraints are:
</p><ul>
<li>Do not use <span class="CODE">with</span>.
<li>Do not expect <span class="CODE">eval</span> to modify the scope.
<li>Declare global variables before using them.</li>
</ul><p>
I quickly surveyed our current code and only get a few errors here and there. So the transition should be easy enough.
</p>

</div>
<a id="Performances"><h1>Performances</h1></a>
<div class="SECTION">

<p>
Since I had to discard the current run loop accelerator, I tried to use the same techniques in the main run loop:
</p><ul>
<li>Dispatch byte codes with goto instead of switch.</li>
<li>Keep essential pointers in registers: stack, scope, frame, code.</li>
<li>Save and restore registers only when operations require it, because of the host or because of the garbage collector.</li>
<li>Check most frequent kinds of slots first.</li>
<li>Stay in the run loop as much as possible.</li>
<li>Etc</li>
</ul><p>
The results are impressive enough. Here is a comparison between XS 5 and XS 6 with the historical <span class="CODE">speed.js</span>.
Both runtimes were compiled with the same optimizations and ran the script as a program on my Mac.
</p>

<table border=0 cellpadding=0 cellspacing=0>
 <tr>
  <td>&nbsp;</td>
  <td class="NUMBER BEST">XS 5</td>
  <td class="NUMBER">(XS 6)</td>
  <td class="NUMBER BEST">XS 6</td>
  <td>&nbsp;</td>
 </tr>
 <tr>
  <td>Global looping</td>
  <td class="NUMBER"> 5.766.664   </td>
  <td class="NUMBER"> 8.163.894   </td>
  <td class="NUMBER BEST">18.257.459   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Closure looping</td>
  <td class="NUMBER"> 6.317.868   </td>
  <td class="NUMBER"> 19.238.116   </td>
  <td class="NUMBER BEST"> 20.481.229   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Local looping</td>
  <td class="NUMBER BEST"> 24.274.990   </td>
  <td class="NUMBER"> 18.397.633   </td>
  <td class="NUMBER"> 22.354.662   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Call empty function</td>
  <td class="NUMBER"> 6.735.941   </td>
  <td class="NUMBER"> 10.285.255   </td>
  <td class="NUMBER BEST"> 15.348.719   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Call function</td>
  <td class="NUMBER"> 1.744.047   </td>
  <td class="NUMBER"> 2.082.190   </td>
  <td class="NUMBER BEST"> 2.717.505   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Calculation</td>
  <td class="NUMBER"> 942.988   </td>
  <td class="NUMBER"> 2.366.864   </td>
  <td class="NUMBER BEST"> 2.723.912   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Object manipulation</td>
  <td class="NUMBER"> 68.868   </td>
  <td class="NUMBER"> 73.080   </td>
  <td class="NUMBER BEST"> 119.578   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>ECMA string</td>
  <td class="NUMBER"> 214.150   </td>
  <td class="NUMBER BEST"> 318.532   </td>
  <td class="NUMBER"> 282.709   </td>
  <td>repetitions / second</td>
 </tr>
 <tr>
  <td>Total time for test:</td>
  <td class="NUMBER"> 569   </td>
  <td class="NUMBER"> 374   </td>
  <td class="NUMBER BEST"> 265   </td>
  <td>milliseconds</td>
 </tr>
 <tr>
  <td>Sieve time:</td>
  <td class="NUMBER BEST"> 23   </td>
  <td class="NUMBER"> 26   </td>
  <td class="NUMBER"> 31   </td>
  <td>milliseconds</td>
 </tr>
</table>
<p>
I added a "Closure loop" test to highlight the fact that XS 6 handles closures more like locals, while XS 5 handles closures more like globals.
That is important since most applications and libraries will run as modules and since classes, functions and variables declared in modules are closures.
</p><p>
The result of XS 5 for locals is mostly related to clever byte code optimizations developed by our Chinese friends. 
Of course there is nothing to prevent such optimizations in XS 6. 
On the contrary I believe it will be easier to develop them with the new architecture of the parser and byte code compiler.
</p><p>
But the first step would be to port some of of the work of the XS 5 run loop accelerator to the XS 6 main run loop. 
Especially on devices since some assembly code is required.
</p>
<p>
</p><p>
</p
</div>
</body>
</html>
