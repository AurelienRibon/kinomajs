<html>

<head>
<title>XS 6 Modules</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" href="./highlight/styles/xcode.css">
<script src="./highlight/highlight.pack.js"></script>
<style>

a, div, h1, h2, h3, h4, h5, h6, li, ol, p table, tr , td {
	font-family: Arial, Helvetica, Geneva, sans-serif;
}

body {
	margin-left: 30px;
	margin-right: 30px;
}

#TITLE {
	counter-reset:section;
	font-size: 300%;
	margin-bottom: 20px;
}
a {
	text-decoration: none;
}
.L1, .L2 {
	display:block;
	padding-top: 2px;
	padding-bottom: 2px;
}
.L1 {
	counter-reset: subsection;
	margin-left: 10px;
}
.L1:before {
	counter-increment:section;
	content:counter(section) ". ";
}
.L2 {
	display:block;
	font-size: 80%;
	margin-left: 20px;
}
.L2:before {
	counter-increment: subsection;
	content:counter(section) "." counter(subsection) ". ";
}
#BEGIN {
	counter-reset:section;
}
h1 {
	border-top: solid #383838 1px;
	font-weight: normal;
	margin-top: 20px;
	margin-bottom: 5px;
	padding-top: 5px;
}
h1:before {
	counter-increment:section;
	content:counter(section) ". ";
}
.SECTION {
	counter-reset:subsection;
}
h2 {
	border-top: solid #383838 1px;
	font-weight: normal;
	margin-top: 20px;
	margin-bottom: 5px;
	padding-top: 5px;
}
h2:before {
	counter-increment:subsection;
	content:counter(section) "." counter(subsection) ". ";
}
h3 {
	font-style: italic;
	font-weight: normal;
	margin-top: 10px;
	margin-bottom: 0px;
}


pre {
	margin-top: 0px;
	margin-bottom: 0px;
	margin-left: 20px;
	margin-right: 20px;
}

table {
	border-collapse: collapse;
}
tr {
}
td {
	background-color: #f0f0f0;
	border: solid white 1px;
	padding-left: 5px;
	padding-right: 5px;
	padding-top: 2px;
	padding-bottom: 2px;
}
.NUMBER {
	text-align: right;
}
.BEST {
	font-weight: bold;
}
.RESULT {
	margin-left: 20px;
	margin-bottom: 10px;
}
.RESULT span {
	background-color: #e0e0e0;
	color: #383838;
	padding-left: 5px;
	padding-right: 5px;
	padding-top: 2px;
	padding-bottom: 2px;
}
.MAIN {
	line-height: 20px;
	margin-top: 10px;
	margin-bottom: 10px;
}
p {
	line-height: 20px;
	margin-top: 10px;
	margin-bottom: 10px;
}
.CODE {
	font-family: monospace;
	font-size: 120%;
}
</style>

<script>hljs.initHighlightingOnLoad();</script>
</head>

<body>

<div id="TITLE">XS 6 Modules</div>

<div id="BEGIN"></div>
<div id="SECTION">
<h1>CommonJS Modules</h1>

<p>
Firstly let us remember that JS is designed to be interpreted. Browsers and node.js get, parse, compile and run scripts.
</p><p>
CommonJS modules are exploiting that feature. The <span class="CODE">require</span> function creates a function with conventional arguments and with the script as the function body, then calls the created function with conventional parameters. For instance:
</p>
<pre><code class="javascript">var modules = {};
function require(id) {
	var uri = lookupModule(id)
	if (uri in modules)
		return modules[uri];
	var script = loadScript(uri);
	var f = new Function("require", "exports", "module", script)
	var module = {
		exports: {},
		id: id,
		uri: uri.
	}
	f(require, module.exports, module)
	modules[uri] = module.exports;
	return module.exports;
}
</code></pre>
<p>
The conventions of node.js are slightly different but the process is the same.
</p><p>
Notice that it is the usage of the script, instead of its source code, that determines how it is parsed, compiled and run. However the generated syntax tree and byte codes are quite different.
</p><p>
To deliver byte code instead of source code, XSC needs to know what it is parsing and compiling. That is why we have <span class="CODE">//@program</span> or <span class="CODE">//@module</span> comments at the beginning of the program or module files.
</p>

<h1>ECMAScript Programs</h1>
<p>
In node.js, everything is a module. In KinomaJS, shells and applications are programs which can include programs and require modules; modules can only require modules. 
</p><p>
Since a module is parsed and compiled as a function, all variables in the body of the module are local variables and all functions use closures to access and assign them. Compare the same code as a program and as a module...
</p>

<pre><code class="javascript">//@program
var oops = "oops"; // define a global
var read = function() {
	return oops; // access a global
}
var write = function(it) {
	oops = it; // assign a global
}
</code></pre>

<pre><code class="javascript">//@module
var oops = "oops"; // define a local of the function created by require with the script
var read = function() {
	return oops; // access a closure
}
var write = function(it) {
	oops = it; // assign a closure
}
</code></pre>
<p>
Alas XS used to limit the number of locals to 127 and closures used to be twice slower than globals. That is mostly why we are still using programs. XS6 does not have such a limitation and closures are now almost as fast as locals.
</p><p>
Notice also that the only way to use features exported by a module requires an indirection, which does not help the performances either:
</p>
<pre><code class="javascript">var OOPS = require("oops");
OOPS.write("oops");
trace(OOPS.read());
</code></pre>
<p>
ECMAScript 6 allows direct references to features:
</p>
<pre><code class="javascript">import { read, write } from "wow";
write("wow");
trace(read());
</code></pre>
<p>
So we are ready to use only modules, but, of course, we want to use ECMAScript 6 modules instead of CommonJS modules...
</p>

<h1>Compatibility</h1>
<p>
Because of Create, we have a lot of code that uses ECMAScript programs and CommonJS modules.
</p><p>
For XML code, there are no problems since kpr2js can be updated to generate ECMAScript 6 modules. For JS code, XS6 takes advantage of the <span class="CODE">//@program</span> or <span class="CODE">//@module</span> comments at the beginning of the files.
</p><p>
ECMAScript programs are compiled into ECMAScript 6 modules that export nothing. Notice that the <span class="CODE">include</span> function is processed by the compiler instead of being a kind of <span class="CODE">eval</span> function. So a program that consists into several files is compiled into one ECMAScript 6 module.
</p><p>
CommonJS modules are prefixed and suffixed to become ECMAScript 6 modules.
</p>
<pre><code class="javascript">//@module
var wow = "wow";
exports.read = function() {
	return wow;
}
exports.write = function(it) {
	wow = it;
}
</code></pre>
<p>
becomes
</p>
<pre><code class="javascript">var exports = {};
var module = {
	exports,
	id: this.id,
	uri: this.uri,
}
var wow = "wow";
exports.read = function() {
	return wow;
}
exports.write = function(it) {
	wow = it;
}
export default module.exports;
</code></pre>
<p>
Also XS6 compiles CommonJS modules and ECMAScript programs in the sloppy mode while ECMAScript 6 modules always use the strict mode.
</p><p>
Without <span class="CODE">//@program</span> or <span class="CODE">//@module</span> comments at the beginning, a file is considered to be an ECMAScript 6 module and compiled accordingly.
</p>

<h1>Require</h1>
<p>
In ECMAScript 6 only modules can use the import and export directives. Moreover the import and export directives are neither expressions nor statements, they are only allowed in the script itself. Two consequences:
</p><ul>
<li>ECMAScript programs cannot use the import and export directives.</li>
<li>CommonJS modules cannot use the import and export directives since the script becomes a function body.</li>
</ul><p>
Notice that such consequences are enforced by XS6, even when XS6 transforms ECMAScript programs and CommonJS modules for the sake of compatibility.
</p><p>
But the main difference is that there is no way to load explicitly a module. For instance:
</p>
<pre><code class="javascript">var oops;
if (whatever)
	oops = require("oops")
else
	oops = require("wow")
</code></pre>
<p>
has not equivalent in ECMAScript 6. That would break some applications. So XS6  implements a <span class="CODE">require</span> function that loads ECMAScript 6 modules and returns their default export.
</p><p>
Moreover, for the sake of the micro-controller, XS6 introduces a <span class="CODE">require.weak</span> function which allows to load modules explicitly like the <span class="CODE">require</span> function, but which allows the garbage collector to unload modules implicitly.  
</p>

<h1>Hybrid Modules</h1>
<p>
In node.js, modules are either in JS or in C. That is what XS6 tried for a while but, eventually, XS6 supports JS only modules or hybrid modules with JS and C parts.
</p><p>
Firstly, it is  a matter of granularity. Often only a few functions need to be implemented in C, for the sake of performance, for platform features, etc. That is our experience with XS so far and we want the same convenience with modules. 
</p><p>
Then, even when most of the module implementation is in the C part, it makes sense to define the module interface in the JS part: it is easier to write and to read than macros in C. Tools can generate the necessary glue.
</p><p>
Alas there is no standard syntax to define host functions (JS functions with C callbacks) or host objects (JS objects with C data and destructors). For years XS used XML for that and it still works thru xs2js.
</p><p>
We reviewed how other engines extended the standard syntax but no solutions feel relevant. We want the extension to be obviously alien and we want to support both host functions and host objects. So we propose our own.
</p><p>
To define a host function, replace the body of the function with @ followed by a string corresponding to the identifier of a C callback.
</p>
<pre><code class="javascript">function wow(it) @ "c_wow";
</code></pre>
<p>
Notice that it works for all occurrences of a function body. For instance:
</p>
<pre><code class="javascript">(function(it) @ "c_wow")("anonymous");

var object = {
	oops(it) @ "c_oops",
	wow(it) @ "c_wow",
},
</code></pre>
<p>
To define a host object, just use @ followed by a string corresponding to the identifier of a C destructor.
</p>
<pre><code class="javascript">var wow = @ "free_wow";
</code></pre>
<p>
Usually a host object is a prototype with a host constructor. That is a host class:
</p>
<pre><code class="javascript">class Wow @ "free_wow" {
	constructor() @ "malloc_wow"
}
</code></pre>
<p>
The usage of @ clearly signals an extension: the code will fail to compile outside of XS6 tools. C identifiers are strings because they are no JS identifiers and do not need to relate to the function or object names. 
</p>

<h1>Example</h1>
<p>
From the code of KinomaJS, here is an example in XML:
</p>
<pre><code class="xml">&lt;object name="KPR"&gt;
	&lt;object name="handler" c="KPR_handler"&gt;
		&lt;function name="get behavior" c="KPR_content_get_behavior"/&gt;
		&lt;function name="get message" c="KPR_handler_get_message"/&gt;
		&lt;function name="get path" c="KPR_handler_get_path"/&gt;
		
		&lt;function name="set behavior" params="it" c="KPR_content_set_behavior"/&gt;
		&lt;function name="set duration" c="KPR_content_set_duration"/&gt;
		&lt;function name="set fraction" c="KPR_content_set_fraction"/&gt;
		&lt;function name="set interval" c="KPR_content_set_interval"/&gt;
		&lt;function name="set time" c="KPR_content_set_time"/&gt;

		&lt;function name="download" params="message, url" c="KPR_handler_download"/&gt;
		&lt;function name="invoke" params="message, type" c="KPR_handler_invoke"/&gt;
		&lt;function name="redirect" params="url, mime" c="KPR_handler_redirect"/&gt;
		&lt;function name="upload" params="message, url, at" c="KPR_handler_upload"/&gt;
		&lt;function name="uploadChunk" params="message, chunk" c="KPR_handler_uploadChunk"/&gt;
		&lt;function name="wait" params="duration" c="KPR_handler_wait"/&gt;
	&lt;/object&gt;
&lt;/object&gt;
&lt;function name="Handler" params="path" prototype="KPR.handler" c="KPR_Handler"/&gt;
&lt;!-- Handler.get(url) --&gt;
&lt;!-- Handler.put(handler) --&gt;
&lt;!-- Handler.remove(handler) --&gt;
&lt;program c="Handler_patch"/&gt;
</code></pre>
<p>
Here it is again, in JS with the proposed extension:
</p>
<pre><code class="javascript">class Handler @ "KPR_handler" {
	constructor(path) @ "KPR_Handler"
	
	get behavior() @ "KPR_content_get_behavior"
	get message() @ "KPR_handler_get_message"
	get path() @ "KPR_handler_get_path"
	
	set behavior(it) @ "KPR_content_set_behavior"
	set duration(it) @ "KPR_content_set_duration"
	set fraction(it) @ "KPR_content_set_fraction"
	set interval(it) @ "KPR_content_set_interval"
	set time(it) @ "KPR_content_set_time"

	download(message, url) @ "KPR_handler_download"
	invoke(message, type) @ "KPR_handler_invoke"
	redirect(url, mime) @ "KPR_handler_redirect"
	upload(message, url, at) @ "KPR_handler_upload"
	uploadChunk(message, chunk) @ "KPR_handler_uploadChunk"
	wait(duration) @ "KPR_handler_wait"
	
	static get(url) @ "KPR_Handler_get";
	static put(handler) @ "KPR_Handler_put";
	static remove(handler) @ "KPR_Handler_remove";
}
</code></pre>

<h1>Tools</h1>
<p>
xsc6 compiles one .js file into one .xsb file (module binary file). By default xsc6 compiles an ECMAScript 6 module and generates .xs.h and .xs.c files if the @ extension is allowed and used. The required parameter is the path of the .js file. The options are:
</p><ul>
<li><b>-c</b>: Allow the @ extension</li>
<li><b>-d</b>: Compile file and line byte codes for the debugger.</li>
<li><b>-e</b>: Embed host functions and host objects descriptions instead of generating .xs.h and .xs.c files. Required to link the module with xsl6.</li>
<li><b>-m</b>: Compile a CommonJS module instead of a module.</li>
<li><b>-o directory</b>: The output directory. Defaults to the current directory.</li>
<li><b>-p</b>: Compile a program instead of a module.</li>
<li><b>-t directory</b>: The temporary directory. Defaults to the output directory. Used for the .h and .c files, if any.</li>
</ul><p>
xsl6 links several .xsb files into one .xsa file (modules archive file) and generates .xs.h and .xs.c files if necessary. The required parameters are the paths of the .jsb files. The options are:
</p><ul>
<li><b>-a name</b>: The name of the archive. Defaults to "a".</li>
<li><b>-b directory</b>: The base directory. Defaults to the current directory. The base directory must be a common part of the paths of the .jsb files.</li>
<li><b>-o directory</b>: The output directory. Defaults to the current directory.</li>
<li><b>-r modulo</b>: The modulo to hash symbols. With such option, xsl6 generates symbols slots in the .xs.c file instead of symbols in the archive.</li>
<li><b>-t directory</b>: The temporary directory. Defaults to the output directory. Used for the .xs.h and .xs.c files, if any.</li>
</ul><p>
Inside the archive, modules have relative paths to the archive. xsl6 creates relative paths by removing the base directory from the paths of the .jsb files.
</p>
<p>
</p><p>
</p><p>
</p><p>
</p>
</div>
</body>
</html>
