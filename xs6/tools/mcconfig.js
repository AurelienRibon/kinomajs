
import TOOL from "tool";
import * as FS from "fs";

class File {
	constructor(path) {
		this.fd = FS.openSync(path, "w");
		this.slash = "/";
	}
	close() {
		FS.closeSync(this.fd);
		delete this.fd;
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		FS.writeSync(this.fd, string);
	}
}

export class MakeFile extends File {
	constructor(path) {
		super(path)
	}
	generate(tool) {
		this.line('# WARNING: This file is automatically generated by config. Do not edit. #');

		if (tool.debug)
			this.line("DEBUG = 1");
		this.line("XS_DIR = ", tool.xsPath);
		this.line("MC_DIR = ", tool.mcPath);
		
		this.line("BIN_DIR = ", tool.binPath);
		this.line("MOD_DIR = ", tool.modPath);
		this.line("TMP_DIR = ", tool.tmpPath);
		
		this.write("C_INCLUDES =");
		this.write("\\\n\t-I$(XS_DIR)/includes");
		this.write("\\\n\t-I$(XS_DIR)/sources");
		if (tool.platform == "mac")
			this.write("\\\n\t-I$(XS_DIR)/sources/tool");
		this.write("\\\n\t-I$(MC_DIR)");
		for (var folder of tool.cFolders) {
			this.write("\\\n\t-I");
			this.write(folder);
		}
		this.write("\\\n\t-I$(MOD_DIR)");
		this.write("\\\n\t-I$(TMP_DIR)");
		this.line("");
		this.write("MODULES =");
		for (var result of tool.jsFiles) {
			this.write("\\\n\t$(MOD_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.write("OBJECTS =");
		for (var result of tool.cFiles) {
			this.write("\\\n\t$(TMP_DIR)/");
			this.write(result.target);
		}	
		this.line("");
		this.line("");
		
		var path = tool.mcPath + "/manifest." + tool.platform + ".mk";
		this.write(FS.readFileSync(path));
		this.line("");
	
		for (var result of tool.jsFiles) {
			var source = result.source;
			var sourceParts = tool.splitPath(source);
			var target = result.target;
			var targetParts = tool.splitPath(target);
			if (sourceParts.name == targetParts.name) {
				this.line("$(MOD_DIR)/", target, ": ", source);
				if (tool.debug)
					this.line("\t$(XSC) -e -d -c -o $(@D) $<");
				else
					this.line("\t$(XSC) -e -c -o $(@D) $<");
			}
			else {
				this.line("$(MOD_DIR)/", target, ": $(TMP_DIR)/", sourceParts.name, ".xsb");
				this.line("\tcp -p $< $@");
				this.line("$(TMP_DIR)/", sourceParts.name, ".xsb: ", source);
				if (tool.debug)
					this.line("\t$(XSC) -e -d -c -o $(@D) $<");
				else
					this.line("\t$(XSC) -e -c -o $(@D) $<");
			}
		}

		for (var result of tool.cFiles) {
			var source = result.source;
			var sourceParts = tool.splitPath(source);
			var target = result.target;
			var targetParts = tool.splitPath(target);
			this.line("$(TMP_DIR)/", target, ": ", source);
			this.line("\t$(CC) $< $(C_OPTIONS) $(C_INCLUDES) -o $@");
		}
	}
}

var platformNames = {
	k5: "k5",
	mac: "mac",
	macosx: "mac",
	MacOSX: "mac",
};

class Tool extends TOOL {
	constructor(argv) {
		super(argv);
		this.homePath = process.getenv("F_HOME");
		if (!this.homePath)
			throw new Error("F_HOME: variable not found!");
		this.xsPath = this.homePath + "/xs6";
		this.mcPath = this.xsPath + "/sources/mc";
			
		this.binPath = null;
		this.debug = false;
		this.make = false;
		this.manifestPath = null;
		this.outputPath = null;
		this.platform = null;
		this.tmpPath = null;
		this.windows = this.currentPlatform == "win";
		this.slash = this.windows ? "\\" : "/";
		
		var name, path;
		var argc = argv.length;
		for (var argi = 1; argi < argc; argi++) {
			var option = argv[argi];
			switch (option) {
			case "-d":
				this.debug = true;
				break;
			case "-m":
				this.make = true;
				break;
			case "-o":
				argi++;	
				if (argi >= argc)
					throw new Error("-o: no directory!");
				name = argv[argi];
				if (this.outputDirectory)
					throw new Error("-o '" + name + "': too many directories!");
				path = this.resolveDirectoryPath(name);
				if (!path)
					throw new Error("-o '" + name + "': directory not found!");
				this.outputPath = path;
				break;
			case "-p":
				argi++;	
				if (argi >= argc)
					throw new Error("-p: no platform!");
				name = argv[argi];
				if (this.platform)
					throw new Error("-p '" + name + "': too many platforms!");
				if (name in platformNames)
					name = platformNames[name];
				this.platform = name;
				break;
			default:
				name = argv[argi];
				if (this.manifestPath)
					throw new Error("'" + name + "': too many manifests!");
				path = this.resolveFilePath(name);
				if (!path)
					throw new Error("'" + name + "': manifest not found!");
				this.manifestPath = path;
				break;
			}
		}
		if (!this.manifestPath) {
			path = this.resolveFilePath("manifest.json");
			if (path)
				this.manifestPath = path;
			else
				throw new Error("no manifest!");
		}
		if (!this.outputPath)
			this.outputPath = this.homePath + "/xs6";
		if (!this.platform) {
			if (this.currentPlatform == "linux")
				this.platform = "linux/gtk";
			else
				this.platform = this.currentPlatform;
		}
		this.environment = {
			"F_HOME": this.homePath,
		}
	}
	createDirectories(path, first, last) {
		FS.mkdirSync(path);
		path += this.slash + first;
		FS.mkdirSync(path);
		let parts = this.platform.split("/");
		path += this.slash + parts[0];
		FS.mkdirSync(path);
		if (parts.length > 1) {
			path += this.slash + parts[1];
			FS.mkdirSync(path);
		}
		if (this.debug) 
			path += this.slash + "debug";
		else
			path += this.slash + "release";
		FS.mkdirSync(path);
		path += this.slash + last;
		FS.mkdirSync(path);
		return path;
	}
	filterItems(manifest, platform, name) {
		if (name in platform) {
			let targets = manifest[name];
			let sources = platform[name];
			manifest[name] = targets.concat(sources);
		}
	}
	filterManifest(manifest) {
		if (!("build" in manifest))
			manifest.build = {};
		if (!("modules" in manifest))
			manifest.modules = {};
		if ("platforms" in manifest) {
			let platforms = manifest.platforms;
			for (let name in platforms) {
				let value = platforms[name];
				if (name in platformNames)
					name = platformNames[name];
				if (this.platform == name) {
					this.filterPlatform(manifest, value);
				}
				else {
					name += "/";
					if (this.platform.indexOf(name) == 0) {
						this.filterPlatform(manifest, value);
						if ("platforms" in value) {
							let _platforms = value.platforms;
							for (let _name in _platforms) {
								let _value = _platforms[_name];
								if (_name in platformNames)
									_name = platformNames[_name];
								if (this.platform == name + _name) {
									this.filterPlatform(manifest, _value);
								}
							}
						}
					}
				}
			}
			delete manifest.platforms;
		}
		let properties = manifest.build;
		for (let name in properties) {
			let value = properties[name];
			if (typeof value == "string")
				this.environment[name] = this.resolveVariable(value);
			else
				this.environment[name] = value;
		}
	}
	filterPlatform(manifest, platform) {
		this.filterProperties(manifest, platform, "build");
		this.filterProperties(manifest, platform, "modules");
	}
	filterProperties(manifest, platform, name) {
		if (name in platform) {
			let targets = manifest[name];
			let sources = platform[name];
			for (let name in sources) {
				let source = sources[name];
				if (source == null) 
					delete targets[name];
				else if (name in targets) {
					let target = targets[name];
					if (target instanceof Array)
						targets[name] = target.concat(source);
					else if (source instanceof Array)
						targets[name] = [target].concat(source);
					else
						targets[name] = source
				}
				else
					targets[name] = source
			}
		}
	}
	processModules(modules) {
		for (var target in modules) {
			var sources = modules[target];
			if (target == "~") {
				if (sources instanceof Array) {
					for (var source of sources) 
						this.processSource(target, source);
				}
				else
					this.processSource(target, sources);
			}
			else {
				var slash = target.lastIndexOf("/");
				if (slash >= 0) {
					var path = target.slice(0, slash);
					if (!this.jsFolders.already[path]) {
						this.jsFolders.already[path] = true;
						this.jsFolders.push(path);
					}
				}
				var star = target.lastIndexOf("*");
				if (star >= 0) {
					target = target.slice(0, star);
					if (sources instanceof Array) {
						for (var source of sources) 
							this.processSource(target, source);
					}
					else
						this.processSource(target, sources);
				}
				else {
					var source = this.resolveVariable(sources);
					var path = source + ".js";
					if (FS.existsSync(path) > 0) {
						var parts = this.splitPath(path);
						if (!this.jsFiles.already[path]) {
							this.jsFiles.already[path] = true;
							this.jsFiles.push({
								target: target + ".xsb",
								source: path
							});
						}
					}
					var path = source + ".c";
					if (FS.existsSync(path) > 0) {
						var parts = this.splitPath(path);
						if (!this.cFiles.already[path]) {
							this.cFiles.already[path] = true;
							this.cFiles.push({
								target: parts.name + ".o",
								source: path
							});
						}
					}
					var path = source + ".h";
					if (FS.existsSync(path) > 0) {
						var parts = this.splitPath(path);
						var directory = parts.directory;
						if (!this.cFolders.already[directory]) {
							this.cFolders.already[directory] = true;
							this.cFolders.push(directory);
						}
					}
				}
			}
		}
		this.jsFiles.sort((a, b) => a.target.compare(b.target));
		this.cFiles.sort((a, b) => a.target.compare(b.target));
	}
	processSource(target, source) {
		var include = target != "~";
		source = this.resolveVariable(source);
		var star = source.lastIndexOf("*");
		if (star >= 0) {
			var slash = source.lastIndexOf("/");
			var directory = source.slice(0, slash);
			var prefix = source.slice(slash + 1, star);
			var names = FS.readDirSync(directory);
			var c = names.length;
			for (var i = 0; i < c; i++) {
				var name = names[i];
				if (!prefix || name.startsWith(prefix)) {
					var path = directory + "/" + name;
					var parts = this.splitPath(path);
					if (parts.extension == ".js") {
						if (!this.jsFiles.already[path]) {
							this.jsFiles.already[path] = true;
							if (include)
								this.jsFiles.push({
									target: target + parts.name.slice(prefix.length) + ".xsb",
									source: path
								});
						}
					}
					else if (parts.extension == ".c") {
						if (!this.cFiles.already[path]) {
							this.cFiles.already[path] = true;
							if (include)
								this.cFiles.push({
									target: parts.name + ".o",
									source: path
								});
						}
					}
					else if (parts.extension == ".h") {
						if (!this.cFolders.already[directory]) {
							this.cFolders.already[directory] = true;
							if (include)
								this.cFolders.push(directory);
						}
					}
				}
			}
		}
		else {
			var path = source + ".js";
			if (FS.existsSync(path) > 0) {
				var parts = this.splitPath(path);
				if (!this.jsFiles.already[path]) {
					this.jsFiles.already[path] = true;
					if (include)
						this.jsFiles.push({
							target: target + parts.name + ".xsb",
							source: path
						});
				}
			}
			var path = source + ".c";
			if (FS.existsSync(path) > 0) {
				var parts = this.splitPath(path);
				if (!this.cFiles.already[path]) {
					this.cFiles.already[path] = true;
					if (include)
						this.cFiles.push({
							target: parts.name + ".o",
							source: path
						});
				}
			}
			var path = source + ".h";
			if (FS.existsSync(path) > 0) {
				var parts = this.splitPath(path);
				var directory = parts.directory;
				if (!this.cFolders.already[directory]) {
					this.cFolders.already[directory] = true;
					if (include)
						this.cFolders.push(directory);
				}
			}
		}
	}
	resolveVariable(value) {
		return value.replace(/\$\(([^\)]+)\)/g, (offset, value) => {
			if (value in this.environment)
				return this.environment[value];
			return process.getenv(value);
		});
	}
	run() {
		var path = this.manifestPath;
		var buffer = FS.readFileSync(path);
		var manifest = JSON.parse(buffer);
		this.filterManifest(manifest);
		this.jsFiles = [];
		this.jsFiles.already = {};
		this.jsFolders = [];
		this.jsFolders.already = {};
		this.cFiles = [];
		this.cFiles.already = {};
		this.cFolders = [];
		this.cFolders.already = {};
		this.cOptions = [];
		this.libraries = [];
		this.linkOptions = [];
		this.processModules(manifest.modules);
		if (!this.binPath)
			this.binPath = this.createDirectories(this.outputPath, "bin", (this.platform == "mac") ? "modules" : "mc");
		if (!this.tmpPath)
			this.tmpPath = this.createDirectories(this.outputPath, "tmp", "mc");
		this.modPath = this.tmpPath + "/modules";
		FS.mkdirSync(this.modPath);
		for (var folder of tool.jsFolders)
			FS.mkdirSync(this.modPath + "/" + folder);
		var path = this.tmpPath + "/makefile";
		var file = new MakeFile(path);
		file.generate(this);
		if (this.make)
			process.then("make", "-f", path);
	}
}
	
		
var tool = new Tool(process.execArgv());
tool.run();
