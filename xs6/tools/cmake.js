/*
 *     Copyright (C) 2010-2015 Marvell International Ltd.
 *     Copyright (C) 2002-2010 Kinoma, Inc.
 *
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 */
import * as FS from "fs";
import * as MAKE from "make";

function toCMakePath(tool, path) {
	return path.replace("\\", "/").replace(tool.homePath, "${F_HOME}");
}

function fixVariable(tool, item) {
	return item.replace("(", "{").replace(")", "}");
}

class File {
	constructor(path) {
		this.fd = FS.openSync(path, "w");
		this.slash = "/";
	}
	close() {
		FS.closeSync(this.fd);
		delete this.fd;
	}
	line(...strings) {
		for (var string of strings)
			this.write(string);
		this.write("\n");
	}
	write(string) {
		FS.writeSync(this.fd, string);
	}
}

export class Makefile extends MAKE.Makefile {
	generateRules(tool, file, path) {
		file.line("list(APPEND LIBRARIES ", this.name, ")");
	}
	generateVariables(tool, file, path) {
		if (this.cIncludes.length) {
			for (let item of this.cIncludes)
				file.line("list(APPEND ", this.name, "_C_INCLUDES ", toCMakePath(tool, item), ")");
		}
		if (this.cOptions.length) {
			for (let item of this.cOptions) {
				var regexpStr = /\$([^)]*\))/;
				var defs = [];
				var incs = [];
				var copts = [];
				switch (item.match(/"?([-\/].)/)[1]) {
					case "-D":
						defs.push(item);
						break;
					case "/D":
						defs.push(item);
						break;
					case "-U":
						defs.push(item);
						break;
					case "/U":
						defs.push(item);
						break;
					case "-I":
						incs.push(item.match(/"?-I(.*)/)[1]);
						break;
					case "/I":
						incs.push(item.match(/"?\/I(.*)/)[1]);
						break;
					default:
						copts.push(item);
				}

				for (let item of incs)
					file.line("list(APPEND ", this.name, "_C_INCLUDES ", toCMakePath(tool, item), ")");
				for (let item of defs)
					file.line("list(APPEND ", this.name, "_C_DEFINITIONS ", fixVariable(tool, item), ")");
				for (let item of copts)
					file.line("list(APPEND ", this.name, "_C_OPTIONS ",  fixVariable(tool, item), ")");
			}
		}
		if (this.headers.length) {
			for (let item of this.headers)
				file.line("list(APPEND ", this.name, "_HEADERS ", toCMakePath(tool, item), ")");
		}
		if (this.sources.length) {
			for (let item of this.sources)
				file.line("list(APPEND ", this.name, "_SOURCES ", toCMakePath(tool, item), ")");
		}
		if (this.seperate) {
			for (let library of this.libraries) {
				file.line("list(APPEND ", this.name, "_LIBRARIES ", library, ")");
			}
		}
	}
}

export class Manifest extends MAKE.Manifest {
	get Makefile() {
		return Makefile;
	}
	generate(tool, tmp, bin) {
		// this.generateDirectories(tool, tmp);
		this.generateC(tool, tmp);
		this.generateXS(tool, tmp);
		this.generateMAKE(tool, tmp, bin);
	}
	generateMAKE(tool, tmp, bin) {
		var path = tool.joinPath({ directory: tmp, name: "CMakeLists", extension: ".txt" });
		var file = new File(path);

		file.line("# WARNING: This file is automatically generated by config. Do not edit. #\n");

		file.line("cmake_minimum_required(VERSION 2.8.8)\n");

		file.line("project(fsk)\n");

		file.line("file(TO_CMAKE_PATH $ENV{F_HOME} F_HOME)");

		this.generatePlatformVariables(tool, file, tmp, bin);

		file.line("include(${F_HOME}/xs6/tools/cmake/CMakeLists.txt)");

		file.line("set(TMP_DIR ", toCMakePath(tool, tmp), ")");
		file.write("set(SUPPORT_XS_DEBUG ");
		file.write((tool.debug || this.tree.xsdebug.enable) ? 1 : 0);
		file.write(")\n");

		this.generateXSVariables(tool, file);
		this.generateResourcesVariables(tool, file);

		for (let makefile of this.makefiles)
			file.line("include(", makefile.name, ".txt)");

		file.line("set(C_INCLUDES ${F_HOME}/xs6/includes ${TMP_DIR} ${TMP_DIR}/src ${FskPlatform_C_INCLUDES})");
		if (tool.windows)
			file.line("set(C_OPTIONS /Fd${TMP_DIR\\fsk.pdb /Dxs6=1 ${FskPlatform_C_INCLUDES})");
		else
			file.line("set(C_OPTIONS -DXS6=1 ${FskPlatform_C_OPTIONS})");
		file.line("set(C_DEFINITIONS ${FskPlatform_C_DEFINITIONS})");
		file.line("set(HEADERS ${F_HOME}/xs6/includes/xs.h ${FskPlatform_HEADERS})");

		for (let item of this.tree.libraries) {
			// file.line("\t", item);
			var parts = item.split(" ");
			if (parts[0] === "-framework")
				file.line("LOCAL_FIND_LIBRARY(", parts[1], ")");
			else
				file.line("list(APPEND LIBRARIES ", item, ")");
		}

		file.line("set(SEPARATE");
		for (let makefile of this.makefiles)
			if (Makefile.separate)
				file.line("\t${SEPARATE_DIR}/lib" + makefile.name + ".so");
		file.line("\t)");

		this.generateManifestRules(tool, file);
		this.generateResourcesRules(tool, file);
		this.generateXSRules(tool, file);
		for (let makefile of this.makefiles) {
			var makePath = tool.joinPath({directory: tmp, name: makefile.name, extension: ".txt"});
			var makeFile = new File(makePath);
			makefile.generateVariables(tool, makeFile, tmp);
			if (makefile.sources.length) {
				makefile.generateRules(tool, makeFile, tmp);
				file.line("BUILD_LIBRARY(NAME ", makefile.name, ")");
				if (makefile.seperate)
					makefile.generateSeparateRules(tool, file, tmp);
			}
			makeFile.close();
		}

		file.line("list(APPEND Fsk_SOURCES ${TMP_DIR}/FskManifest.c)");
		file.line("list(APPEND Fsk_SOURCES ${TMP_DIR}/FskManifest.xs.c)");
		file.line("set_source_files_properties(${TMP_DIR}/FskManifest.xs.c ${TMP_DIR}/FskManifest.xs.h PROPERTIES GENERATED TRUE)");

		this.generateTargetRules(tool, file);

		file.close();
	}
	generateManifestRules(tool, file) {
	}
	generateResourcesVariables(tool, file) {
		file.line("set(MODULES");
		file.line("\t${TMP_DIR}/FskManifest.xsb");
		for (let item of this.tree.xmlPaths)
			file.line("\t${TMP_DIR}/", toCMakePath(tool, item.destinationPath), ".xsb");
		for (let item of this.tree.jsPaths)
			file.line("\t${TMP_DIR}/", toCMakePath(tool, item.destinationPath), ".xsb");
		file.line("\t)");
	}
	generateTargetRules(tool, file) {
		file.write(this.getTargetRules(tool));
	}
	generateXSRules(tool, file) {
		file.line("XSL(NAME FskManifest)");
	}
	generateXSVariables(tool, file) {
		file.line("set(XSC_OPTIONS");
		file.line("\t-b");
		if (tool.debug)
			file.line("\t-d");
		for (let item of this.xsIncludes)
			file.line("\t-i ", toCMakePath(tool, item));
		if (tool.debug)
			file.line("\t-t debug");
		file.line("\t-t KPR_CONFIG");
		file.line("\t-t XS6");
		for (let item of this.xsOptions)
			file.line("\t", item);
		file.line("\t)");
		file.line("set(XSC_PACKAGES");
		for (let item of this.xsSources)
			file.line("\t", toCMakePath(tool, item));
		file.line("\t)");
	}
	generatePlatformVariables(tool, file, tmp, bin) {
		file.line("set(TARGET_PLATFORM ", tool.platform, ")");
		var variables = this.getPlatformVariables(tool, tmp, bin);
		for (let name in variables) {
			var value = variables[name].replace("(", "{").replace(")", "}");
			file.line("set(", name, " ", toCMakePath(tool, value), ")");
		}
	}
	generateResourcesRules(tool, file) {
		for (let item of this.tree.xmlPaths) {
			let parts = tool.splitPath(item.destinationPath);
			file.line("XML2XSB(SOURCE ", toCMakePath(tool, item.sourcePath), " DESTINATION ", parts.directory, ")");
		}
		for (let item of this.tree.jsPaths) {
			let parts = tool.splitPath(item.destinationPath);
			file.line("JS2XSB(SOURCE ", toCMakePath(tool, item.sourcePath), " DESTINATION ", parts.directory, ")");
		}
		for (let item of this.tree.otherPaths)
			file.line("COPY(SOURCE ", toCMakePath(tool, item.sourcePath), " DESTINATION ${APP_DIR}/", item.destinationPath, ")");
	}
	getTargetRules(tool) {
		throw new Error("unsupported platform!");
	}
}
